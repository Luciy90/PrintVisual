<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Принтеры — Камеры</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/js/all.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  <style>
    :root {
      /*BASE*/

      --black: 0 0 0;
      --white: 255 255 255;
      --primary: 99 102 241;      /* indigo-500 */
      --secondary: 236 72 153;    /* fuchsia-500 */
      --surface: 15 23 42;        /* slate-900 */
      --surface-alt: 30 41 59;    /* slate-800 */

      --named-driv-font-size: 0.9rem;
      --border-right: 2px;
    }
    #consentModal {
      font-family:'Inter', sans-serif;
    }
    .reveal{opacity:0;transform:translateY(25px)}

    .reveal.show{animation:fadeIn .8s ease forwards}
    @keyframes fadeIn{0%{opacity:0;transform:translateY(25px)}100%{opacity:1;transform:none}}

    body { 
      font-family: 'Inter', sans-serif; 
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    html, body {
      background: 
      linear-gradient(135deg, 
        rgb(var(--base-color1)), 
        rgb(var(--base-color2))
      );
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      height: 100%;
    }
    .bg-cams {
      background-color: rgb(var(--base-color-rgb)/0.98);
    }

    .camera-title { text-shadow: 0 1px 3px #000a; }
    .notification {
      will-change: transform, opacity;
      transition: transform 0.3s ease, opacity 0.3s ease;
      box-sizing: border-box;
      cursor: pointer;
      pointer-events: auto;
      white-space: nowrap;
    }
    .notification.collapsed {
      /*pointer-events: none !important;*/
      animation: bottom 0.6s ease, opacity 0.4s ease;
      bottom: 0px !important;
    }
    #notificationActions {
      position: absolute;
      bottom: 76px;
      right: 25px; /* совпадает с отступом контейнера */
      z-index: 35;
      opacity: 0;
      transform: translateY(4px);
      pointer-events: none;
      transition: all 0.3s ease;
    }
    #notificationActions.show {
      opacity: 0.8;
      transform: translateY(0);
      pointer-events: auto;
    }
    #settingsChangedNotification {
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      margin: 0 auto;
      max-width: inherit;
      background: linear-gradient(135deg, rgb(var(--base-color1)), rgb(var(--base-color2)));
      backdrop-filter: blur(12px);
      border-radius: 1rem;
      box-shadow:
        inset 0 0 0 1px rgb(var(--white)/0.1),
        0 8px 24px rgb(var(--black)/0.25);
      color: rgb(var(--text-rgb));
      font-size: 1.1rem;
      font-weight: 600;
      padding: 1.5rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      opacity: 1;
      animation: inner-pulse 3s infinite ease-in-out;
      transform: translateY(-80px);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      z-index: 30;
    }

    .notif-enter {
      opacity: 0;
      transform: translateY(36px) scale(0.98);
      filter: blur(10px);
      animation: notif-in 0.7s cubic-bezier(.4,0,.2,1) forwards;
      will-change: opacity, transform, filter;
    }


    /* Панель настроек */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      height: 100%;
      width: 100%;
      max-width: 36rem; /* 9 * 4rem = 36rem => xl по Tailwind */
      border-top-left-radius: 1rem; /* rounded-l-2xl */
      border-bottom-left-radius: 1rem;
      box-shadow: 0 25px 50px -12px rgb(var(--black)/0.25); /* shadow-2xl */
      z-index: 50;
      opacity: 0;
      transform: translateX(100%);
      animation: appear 0.3s ease-out forwards;
      background:linear-gradient(114deg, rgb(var(--base-color1)),rgb(var(--base-color2)) 90%);
      border:1.5px solid rgba(120,86,255,.13);
      box-shadow: 0 18px 60px 0 rgba(60,30,90,0.22), 0 2px 8px 0 rgba(0,0,0,0.06);
      backdrop-filter: blur(10px) saturate(1.4);
    }

    /*Заголовок SettingsPanel*/
    .settings-panel-header {
      display: flex;
      align-items: center; /* items-center */
      justify-content: space-between; /* justify-between */
      padding-left: 2rem;  /* px-8 (1rem = 16px → 8 * 0.25rem = 2rem) */
      padding-right: 2rem;
      padding-top: 1.75rem;  /* py-7 (0.25rem * 7 = 1.75rem) */
      padding-bottom: 1.75rem;
      border-bottom-width: 1px; /* border-b */
      border-color: rgba(79, 65, 219, 0.2); /* border-indigo-700/20 */
      background-color: transparent; /* bg-white/0 */
    }


    /* Красивый стиль для кнопки закрытия */
    .close-btn-fancy {
      border: 2px solid rgba(167,139,250,0.28);
      box-shadow:
        0 2px 8px 0 #764ba233,
        0 0.5px 2px 0 #fff5;
      color: #fff;
      border-radius: 1.2em;
      transition:
        background 0.25s, 
        box-shadow 0.22s,
        transform 0.18s,
        border 0.18s;
      position: relative;
      overflow: hidden;
    }
    .close-btn-fancy:hover, .close-btn-fancy:focus {
      background: linear-gradient(120deg, #fff2, rgb(var(--base-color2)) 80%);
      border-color: #a78bfa;
      box-shadow:
        0 8px 22px 0 #a78bfa44,
        0 2px 8px 0 #fff5;
      color: #fff;
      transform: scale(1.08);
    }
    .close-btn-fancy:active {
      transform: scale(0.97) rotate(1deg);
      box-shadow:
        0 1px 6px 0 #764ba233,
        0 0.5px 2px 0 #fff5;
    }

    .close-btn-fancy svg {
      transition: transform 0.22s cubic-bezier(.4,0,.2,1);
    }

    .close-btn-fancy:hover svg, .close-btn-fancy:focus svg {
      transform: rotate(90deg) scale(1.12);
    }

    /* Стилизация подсказки для кнопох хедера */
    .custom-tooltip {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      will-change: transform, background;
      position: absolute;
      bottom: -42px;
      left: 50%;
      transform: translateX(-50%) scale(0.95);
      color: rgb(var(--text-rgb));
      font-size: 11px;
      padding: 6px 16px;
      border-radius: 0.75rem;
      box-shadow: 0 8px 24px 0 rgba(168, 85, 247, 0.15);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.22s cubic-bezier(.4,0,.2,1),
                  transform 0.22s cubic-bezier(.4,0,.2,1);
      z-index: 20;
      white-space: nowrap;
      font-weight: 500;
      letter-spacing: 0.02em;
      user-select: none;
      border: 2px solid rgb(var(--base-color-rgb)/0.3);
      backdrop-filter: saturate(120%);

      /* Градиент + плавная анимация фона */
      background: linear-gradient(
          145deg,
          rgb(var(--base-color1)/0.96),
          rgb(var(--base-color2)/0.96)
        )
        0% 0% / 200% 200%;
      animation: shimmer 4s ease-in-out infinite;
    }

    /* Активируем анимацию при появлении */
    .custom-tooltip.show {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      animation-play-state: running;
    }

    /* Стрелочка-указатель с тем же градиентом */
    .custom-tooltip::after {
      content: '';
      position: absolute;
      left: 50%;
      top: -8px;
      transform: translateX(-50%);
      width: 7px;
      height: 7px;
      background: linear-gradient(
          135deg,
          rgb(var(--base-color1)/0.96),
          rgb(var(--base-color2)/0.96)
        )
        100% 100% / 200% 200%;
      clip-path: polygon(0 100%, 50% 0, 100% 100%);
      z-index: 19;
      animation: shimmer 4s ease-in-out infinite;
    }
    .custom-tooltip.show::after {
      animation-play-state: running;
    }

    /* Плавное «перетекание» градиента */
    @keyframes shimmer {
      0%   { background-position: 10% 10%; }
      50%  { background-position: 90% 90%; }
      100% { background-position: 10% 10%; }
    }

    /* Interface width transition */
    #mainInterfaceContainer {
      transition: max-width 0.22s cubic-bezier(.4,0,.2,1);
    }
    #mainInterfaceContainer, #mainInterfaceContainerCameras {
      box-sizing: border-box;
    }
    /* Горизонтальный разделитель между строками grid */
    #cameraContainer {
      position: relative;
    }

    #cameraContainer::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      height: 5px;
      background-color: rgb(var(--white)/0); /* Цвет разделителя */
      z-index: 0;
      pointer-events: none;
    }
    .horizontal-divider {
      border-radius: 9px; /* Полный скругление — как линия с закруглёнными краями */
      box-shadow: 0 2px 6px rgb(var(--black)/0.05); /* Лёгкая тень */
      transition:
        opacity 0.3s ease,
        background-color 0.3s ease,
        transform 0.3s ease;
    }

    .horizontal-divider:hover {
      transform: scaleX(1.02);
    }
    .divider-hitbox {
      pointer-events: auto;
    }
    

    #floatingToolbar > div {
      backdrop-filter: blur(12px);
    }
    #settingsPanel {
      z-index: 800;
    } 
    /* Разрешаем вертикальную прокрутку внутри панели настроек */
    #settingsPanel .space-y-6 {
      max-height: calc(100vh - 160px); /* Оставить место под заголовок и кнопки */
      overflow-y: visible;
    }


    .card {
      /* color used to softly clip top and bottom of the .words container */
      --bg-color: #141414;
      background-color: var(--bg-color);
      padding: 1rem 2rem;
      border-radius: 1.25rem;
    }
    .loader {
      color: rgb(124, 124, 124);
      font-family: "Poppins", sans-serif;
      font-weight: 500;
      font-size: 25px;
      -webkit-box-sizing: content-box;
      box-sizing: content-box;
      height: 40px;
      padding: 10px 10px;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      border-radius: 8px;
    }
    .words {
      overflow: hidden;
      position: relative;
    }
    .words::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        var(--bg-color) 10%,
        transparent 30%,
        transparent 70%,
        var(--bg-color) 90%
      );
      z-index: 20;
    }
    .word {
      display: block;
      height: 100%;
      padding-left: 6px;
      color: #956afa;
      animation: spin_4991 12s infinite;
    }
    input::placeholder {
      color: #9ca3af; /* серый цвет */
    }

    /* === Кнопки === */
    .button {
      margin: 0;
      height: auto;
      background: transparent;
      padding: 0;
      border: none;
      cursor: pointer;
      --border-right: 3px;
      --text-stroke-color:  rgba(255,255,255,0.01);
      --animation-color: rgb(var(--base-color1));
      --fs-size: 2em;
      letter-spacing: 3px;
      text-decoration: none;
      font-size: 10px;
      font-family: "Arial";
      position: relative;
      text-transform: uppercase;
      color: transparent;
      -webkit-text-stroke: 1px var(--text-stroke-color);
    }
    .btn-3d { 
      transition: box-shadow .22s,transform .16s,background .45s,border .18s; 
      will-change: transform,box-shadow; 
    }
    .btn-3d:hover{
      transform:translateY(-2px) scale(1.04);
      box-shadow:
        0 12px 44px rgb(var(--shedow-rgb)/0.6),
        0 2px 8px rgb(var(--shedow-rgb))
    }
    .glass-btn {
      cursor: pointer;
      position: relative;
      backdrop-filter: opacity(0.5) !important;
      overflow: visible !important; 
    }
    /* Улучшенный эффект при наведении на кнопки */
    .glass-btn:active {
      transform: translateY(1px) scale(0.98);
    }
    /* Анимация при появлении */
    .glass-btn:hover .custom-tooltip,
    .glass-btn:focus-visible .custom-tooltip {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }
    .glass-btn:focus .custom-tooltip,
    .glass-btn:hover .custom-tooltip {
      pointer-events: auto;
    }
    /* Деактивация кнопок при активации импорта настроек*/
    .btn-disabled {
      opacity: 0.6;
      filter: blur(0.7px);
      pointer-events: none;
      transform: scale(0.98);
      transition: all 0.3s ease;
    }
    /* Красивый стиль для кнопки закрытия */
    .close-btn-fancy {
      border: 2px solid rgba(167,139,250,0.28);
      box-shadow:
        0 2px 8px 0 rgb(var(--shedow-rgb)/0.4),
        0 0.5px 2px 0 rgb(var(--shedow-rgb)/0.2);
      color: rgb(var(--text-rgb));
      border-radius: 1.2em;
      transition:
        background 0.25s, 
        box-shadow 0.22s,
        transform 0.18s,
        border 0.18s;
      position: relative;
      overflow: hidden;
    }
    .close-btn-fancy:hover, .close-btn-fancy:focus {
      background: linear-gradient(120deg, rgb(var(--base1-light-rgb)/0.4), rgb(var(--base2-light-rgb)/0.55) 80%);
      border-color: rgb(var(--shedow-rgb)/0.8);
      box-shadow:
        0 8px 22px 0 rgb(var(--shedow-rgb)/0.2),
        0 2px 8px 0 rgb(var(--shedow-rgb)/0.6);
      color: #fff;
      transform: scale(1.08);
    }
    .close-btn-fancy:active {
      transform: scale(0.97) rotate(1deg);
      box-shadow:
        0 1px 6px 0 #764ba233,
        0 0.5px 2px 0 #fff5;
    }
    .close-btn-fancy svg {
      transition: transform 0.22s cubic-bezier(.4,0,.2,1);
    }
    .close-btn-fancy:hover svg, .close-btn-fancy:focus svg {
      transform: rotate(90deg) scale(1.12);
    }


    /* This is the text that appears on hover */
    .hover-text {
      position: absolute;
      box-sizing: border-box;
      content: attr(data-text);
      color: var(--animation-color);
      width: 0%;
      inset: 0;
      border-right: 2px solid var(--animation-color);
      overflow: hidden;
      transition: width 0.8s ease, filter 0.8s ease;
      -webkit-text-stroke: 1px var(--animation-color);
    }

    /* === СТИЛИ ДЛЯ МОДАЛЬНОГО ОКНА === */

    .modal-glass {
      background: rgb(var(--shiftedRightDark-rgb)/0.6);
      backdrop-filter: blur(16px) saturate(140%);
      box-shadow: 0 6px 32px 0 rgba(60,0,130,.18), 0 2px 8px 0 rgba(0,0,0,.12);
      border: 1.5px solid rgba(168, 85, 247, 0.22);
    }
    .ray {
      filter: blur(22px);
      opacity: .7;
      pointer-events: none;
    }

    .social-btn {
      position: relative;
      transition: transform .18s, box-shadow .18s;
      box-shadow:
        0 6px 24px rgb(var(--shedow-rgb)/0.3),
        0 1px 4px rgb(var(--shedow-rgb)/0.1);
      outline: none;
      border: none;
      cursor: pointer;
    }
    .social-btn svg,
    .social-btn i {
      filter: drop-shadow(0 1px 5px rgb(var(--textInvert-rgb)/0.6));
      stroke: rgb(var(--text-rgb)/0.8);
    }
    .social-btn:focus-visible {
      outline: 2px solid rgb(var(--shedow-rgb));
      outline-offset: 2px;
    }
    .social-btn:hover, .social-btn:focus-visible {
      transform: translateY(-3px) scale(1.08);
      box-shadow: 0 6px 20px 0 rgb(var(--shedow-rgb)/0.6), 0 2px 8px 0 rgb(var(--shedow-rgb)/0.2);
      outline: 1px solid rgb(var(--shedow-rgb)/0.2);
    }
    .tooltip {
      pointer-events: none;
      opacity: 0;
      position: absolute;
      left: 50%;
      top: -55px;
      transform: translateX(-50%) scale(.97);
      background: linear-gradient(
        145deg,
        rgb(var(--base-color1)/0.9),
        rgb(var(--base-color2)/0.9)
      ) 0% 0% / 200% 200%;
      color: rgb(var(--text-rgb));
      padding: 6px 18px;
      font-size: 15px;
      border-radius: 0.75rem;
      font-weight: 500;
      box-shadow:
        0 6px 24px rgb(var(--shedow-rgb)/0.2),
        0 1px 4px rgb(var(--shedow-rgb)/0.6);
      white-space: nowrap;
      z-index: 20;
      border: 1.5px solid #a78bfa44;
      transition: opacity .22s cubic-bezier(.4,0,.2,1), transform .22s cubic-bezier(.4,0,.2,1);
      animation: fadeInTooltip .35s cubic-bezier(.4,0,.2,1);
      backdrop-filter: blur(10px) saturate(120%);
    }

    .social-btn:hover .tooltip, .social-btn:focus-visible .tooltip {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      pointer-events: auto;
    }
    .social-btn .tooltip:after {
      content: '';
      position: absolute;
      left: 50%;
      bottom: -8px;
      transform: translateX(-50%);
      width: 7px;
      height: 7px;
      background: linear-gradient(
        145deg,
        rgb(var(--base-color1)/0.9),
        rgb(var(--base-color2)/0.9)
      ) 0% 0% / 200% 200%;
      border-left: 1.5px solid rgb(var(--base-color2)/0.4);
      border-bottom: 1.5px solid rgb(var(--base-color2)/0.4);
      border-radius: 0 0 4px 0;
      clip-path: polygon(50% 100%, 0 0, 100% 0);
      z-index: 21;
    }


    /* Основные стили карточки */
    .camera-box {
      background: rgba(35,36,56,0.65);
      border-radius: 0.9rem;
      box-shadow: 0 2px 18px 0 rgba(160,120,255,0.13),
        0 1.5px 8px 0 rgba(0,0,0,0.15),
        0 1px 2px 0 #fff1 inset;
      border: 2px solid rgba(255,255,255,0.11);
      backdrop-filter: blur(18px) saturate(180%);
      transition: box-shadow .32s cubic-bezier(.4,0,.2,1),
        transform .36s cubic-bezier(.4,0,.2,1),
        border .24s cubic-bezier(.4,0,.2,1),
        filter .22s cubic-bezier(.4,0,.2,1);
      will-change: transform, box-shadow, filter;
      position: relative;
      overflow: hidden;
      transform-style: preserve-3d;
    }

    .camera-box .camera-img img {
      transition: transform .44s cubic-bezier(.42,1.8,.2,1), filter .28s;
      will-change: transform;
      border-radius: 0.7rem;
      box-shadow: 0 5px 26px 0 rgba(120,50,220,0.08),
        0 1.5px 7px 0 rgba(120,50,220,0.08);
      object-fit: cover;
      width: 100%;
      height: 100%;
      min-height: 140px;
      max-height: 190px;
      display: block;
      cursor: pointer;
      transform-style: preserve-3d;
      z-index: 1;
      /*backface-visibility: hidden;*/
    }

    .camera-box.drag-over {
      outline: none;
      border: 2px solid rgb(var(--shedow-rgb));
      box-shadow: 0 8px 34px 0 rgb(var(--shedow-rgb)/0.8);
    }


    /* Полноэкранный режим */
    .camera-box.fullscreen .zone-right {
      opacity: 0 !important;
      pointer-events: none;
    }
    .camera-box.fullscreen .zone-left {
      cursor: default;
    }
    .camera-box.fullscreen .camera-img img {
      border-radius: 0;
    }

    /* Добавляем градиентный эффект */
    .camera-box::before {
      content: "";
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background:
        linear-gradient(120deg,rgb(var(--base-color-rgb)/0.15) 0%,rgb(var(--avg-light-rgb)/0.07) 100%),
        radial-gradient(ellipse at 80% 10%,rgb(var(--white)/0.11) 0,rgb(var(--white)/0.01) 70%);
      mix-blend-mode: screen;
      opacity: .85;
      transition: opacity .4s;
    }

    /* Эффекты при наведении */
    .camera-box:hover,
    .camera-box:focus-within {
      box-shadow:
        0 12px 44px rgb(var(--shedow-rgb)/0.2),
        0 2px 8px rgb(var(--shedow-rgb)/0.6);
      border: 2px solid rgb(var(--shedow-rgb)/0.5);
      filter: brightness(1.08) saturate(1.11);
      transform: translateY(-2px) scale(1.04) perspective(700px) rotateY(-1.2deg) rotateX(0.7deg);
      z-index: 30;
    }

    /* Стили для изображения камеры */
    .camera-box .camera-img img {
      transition: transform .44s cubic-bezier(.42,1.8,.2,1), filter .28s;
      will-change: transform;
      border-radius: 0.7rem;
      box-shadow: 0 5px 26px 0 rgb(var(--base-color-rgb)/0.08),
        0 1.5px 7px 0 rgb(var(--base-color-rgb)/0.08);
      object-fit: cover;
      width: 100%;
      height: 100%;
      min-height: 140px;
      max-height: 190px;
      display: block;
      cursor: grab;
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }

    /* Улучшенные стили для заголовка камеры */
    .camera-box .camera-title {
      position: absolute;
      bottom: 0.8rem;
      left: 0.8rem;
      max-width: 82%;
      z-index: 3;
      
      /* Улучшенный стеклянный эффект */
      background: rgba(20, 20, 33, 0.65);
      backdrop-filter: blur(8px) saturate(160%);
      border: 1px solid rgb(var(--white)/0.15);
      box-shadow: 
        0 4px 24px -1px rgb(var(--black)/0.24),
        0 1.5px 6px 0 rgb(var(--black)/0.12),
        0 2px 4px 0 rgb(var(--white)/0.05) inset;
      
      /* Улучшенная типографика */
      color: rgb(var(--white)/0.95);
      font-size: var(--named-driv-font-size);
      line-height: 1.48;
      font-weight: 600;
      letter-spacing: -0.01em;
      
      /* Улучшенное оформление */
      padding: 0.28rem 0.48rem 0.2rem;
      border-radius: 0.4rem;
      
      /* Улучшенная читаемость */
      text-shadow: 
        0 1px 4px rgb(var(--black)/0.4),
        0 2px 8px rgb(var(--black)/0.2);
      
      /* Анимация */
      transition: 
        transform 0.2s cubic-bezier(0.4, 0, 0.2, 1),
        background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
        box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Обрезка длинного текста */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Эффект при наведении на карточку */
    .camera-box:hover .camera-title {
      background: rgb(var(--stickyHeader-rgb)/0.75);
      transform: translateY(-2px);
      box-shadow: 
        0 6px 28px -2px rgb(var(--black)/0.28),
        0 2px 8px 0 rgb(var(--black)/0.15),
        0 2px 4px 0 rgb(var(--white)/0.06) inset;
    }
    
    /* Градиентный эффект внизу карточки */
    .camera-box .bottom-glass {
      position: absolute;
      left: 0; 
      right: 0; 
      bottom: 0;
      height: 45%;
      background: linear-gradient(0deg,rgb(var(--white)/0.16) 17%,rgb(var(--white)/0.04) 94%);
      filter: blur(8px);
      z-index: 1;
      pointer-events: none;
    }

    /* Базовые стили для контейнера кнопок */
    .camera-box:not(.camera-disconnected) .zone-right {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 0.75rem;
      padding: 1rem 0.75rem;
      opacity: 0;
      transform: translateX(10px);
      transition: all 0.3s cubic-bezier(.4,0,.2,1);
      z-index: 2;
    }

    /* Появление панели при наведении */
    .camera-box:not(.camera-disconnected):hover .zone-right {
      opacity: 1;
      transform: translateX(0);
    }

    /* Базовые стили кнопок */
    .action-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      border: 1.5px solid rgb(var(--base-color-rgb)/0.3);
      backdrop-filter: blur(5px);
      transition: all 0.25s cubic-bezier(.4,0,.2,1);
    }

    /* Градиентный фон кнопки при наведении */
    .action-icon::before {
      content: '';
      position: absolute;
      inset: -1px;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 1;
    }

    /* Показываем градиент при наведении */
    .action-icon:hover::before {
      opacity: 1;
    }

    /* Стили для иконок внутри кнопок */
    .action-icon i,
    .action-icon svg {
      font-size: 1.15rem;
      color: rgb(var(--avg-light-rgb));
      transition: all 0.25s cubic-bezier(.4,0,.2,1);
      z-index: 2;
      position: relative;
    }

    /* Эффекты при наведении */
    .action-icon:hover {
      transform: translateY(-2px) scale(1.08);
      border-color: rgb(var(--white)/0.3);
      box-shadow: 
        0 4px 20px rgb(var(--shedow-rgb)/0.45),
        0 2px 8px rgb(var(--shedow-rgb)/0.2);
    }
    .action-icon:hover i,
    .action-icon:hover svg {
      color: rgb(var(--white));
      mix-blend-mode: normal;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    }

    /* Анимация при клике */
    .action-icon:active {
      transform: translateY(0) scale(0.95);
    }

    /* Отключенное состояние */
    .camera-box.camera-disconnected .zone-right {
      display: none !important;
    }

    /* Плавная анимация для status-dot */
    .camera-box:not(.camera-disconnected) .status-dot {
      transition: transform 0.3s cubic-bezier(.42,1.8,.2,1);
    }
    .camera-box:not(.camera-disconnected):hover .status-dot {
      transform: scale(1.1);
    }

    /* Стили для отключенных камер */
    .camera-box.camera-disconnected {
        transform: none !important;
        transition: none !important;
        cursor: grab !important; /* Меняем курсор на move для индикации возможности перетаскивания */
        pointer-events: all !important; /* Разрешаем все события указателя */
    }
    .camera-box.camera-disconnected:hover,
    .camera-box.camera-disconnected:focus-within {
        transform: none !important;
        box-shadow: 
        0 4px 20px rgb(var(--shedow-rgb)/0.4),
        0 2px 8px rgb(var(--shedow-rgb)/0.1);
        filter: grayscale(0.1) opacity(0.85) !important;
    }
    .camera-box.camera-disconnected .camera-img {
        pointer-events: none !important;
    }
    .camera-box.camera-disconnected .camera-img img {
        display: none !important;
    }
    .camera-box.camera-disconnected::before {
        opacity: 0.5 !important;
    }

    /* Пустой слот  */
    .camera-box.dammy {
      border: 2px dashed #93c5fd;
      background: linear-gradient(135deg, 
        rgb(var(--avg-light-rgb)), 
        rgb(var(--avg-dark-rgb))
      );
      background-color: rgba(147, 197, 255, 0.01);
      cursor: grab;
    }
    .camera-box.dammy .disconnected-svg,
    .camera-box.dammy .fa-expand {
      display: none !important;
    }
    .camera-box.dammy .camera-title {
      display: none;
    }
    .camera-box.dammy:hover,
    .camera-box.dammy.drag-over {
      border-color: rgb(var(--tetrad1-light-rgb));
      background-color: rgb(var(--tetrad2-light-rgb));
      box-shadow: 
        0 4px 20px rgb(var(--shedow-rgb)/0.4),
        0 2px 8px rgb(var(--shedow-rgb)/0.1);
    }


    /* Индикатор состояния (status-dot) */
    .status-dot {
      position: absolute;
      top: 1.2rem;
      left: 1.1rem;
      width: 12px; 
      height: 12px;
      border-radius: 100%;
      z-index: 2;
      transition: background .22s, box-shadow .22s;
    }

    /* Эффект свечения вокруг точки */
    .status-dot::after {
      content: "";
      position: absolute;
      left: -7px; 
      top: -8px;
      width: 24px; 
      height: 24px;
      border-radius: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
    }
    .status-dot.initial {
      background: radial-gradient(ellipse at 60% 30%, #6b7280 0%, #4b5563 90%);
      box-shadow: 0 0 18px #6b7280bb, 0 0 8px #9ca3afaa, 0 0 2.5px #fff9;
      border: 2px solid #999;
      animation: pulse-initial 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.initial::after {
      background: radial-gradient(circle, #6b728044 40%, transparent 73%);
      animation: pulse-glow-off 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.connect {
      background: radial-gradient(ellipse at 60% 30%, #34d399 0%, #059669 90%);
      box-shadow: 0 0 18px #34d399bb, 0 0 8px #a7f3d0aa, 0 0 2.5px #fff9;
      border: 2px solid #fff;
      animation: pulse-online 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.connect::after {
      background: radial-gradient(circle, #34d39944 40%, transparent 73%);
      animation: pulse-glow-off 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.disconnected {
      background: radial-gradient(ellipse at 60% 30%, #f87171 0%, #b91c1c 90%);
      box-shadow: 0 0 18px #f87171bb, 0 0 8px #fca5a5aa, 0 0 2.5px #fff9;
      border: 2px solid #fff;
      animation: pulse-offline 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.disconnected::after {
      background: radial-gradient(circle, #f8717144 40%, transparent 73%);
      animation: pulse-glow-off 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.warning {
      background: radial-gradient(ellipse at 60% 30%, #fbbf24 0%, #b45309 90%);
      box-shadow: 0 0 18px #fbbf24cc, 0 0 8px #fde68aaa, 0 0 2.5px #fff9;
      border: 2px solid #fff;
      animation: pulse-warning 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .status-dot.warning::after {
      background: radial-gradient(circle, #fbbf2444 40%, transparent 73%);
      animation: pulse-glow-off 1.3s infinite cubic-bezier(.49,1.7,.2,1.2);
    }
    .camera-stub {
      z-index: 1;
      font-size: 1.05rem;
      background: rgb(var(--black)/0.2);
      border-radius: 0.6rem;
      text-align: center;
      pointer-events: auto;
      transition: background 0.2s;
    }
    .camera-stub.items-center p {
      color: rgb(var(--tetrad2-light-rgb)/0.8);
      font-size: 0.5rem;
    }
    .camera-stub.items-center h1 {
      color: rgb(var(--tetrad1-light-rgb)/0.7);
    }


    /* Стили для окна с klipper */
    #cameraSettingsModal {
      will-change: opacity, visibility;
      z-index: 750;
    }
    #cameraSettingsModal .modal-glass {
      background: rgba(30, 27, 75, 0.78);
      backdrop-filter: blur(16px) saturate(140%);
      box-shadow: 0 6px 32px 0 rgba(60,0,130,.18), 0 2px 8px 0 rgba(0,0,0,.12);
    }
    #cameraSettingsModal .action-icon {
      background: rgb(var(--white)/0.1);
      backdrop-filter: blur(8px);
      border: 1px solid rgb(var(--white)/0.2);
    }
    #cameraSettingsModal .action-icon:hover {
      background: rgb(var(--white)/0.2);
      transform: translateY(-2px);
    }
    #cameraSettingsModal .close-settings-modal {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.25s cubic-bezier(.4,0,.2,1);
    }
    .manage-icon:hover svg,
    .expand-icon:hover svg {
      color: rgb(var(--white)/0.85) !important;
    }


    /* Панель настроек */
    .panel-appear {
      opacity: 0;
      transform: 
        translateX(500px) 
        scale(0.95) 
        perspective(1000px) 
        rotateY(-50deg);
      transform-origin: left center;
      filter: blur(8px);
      pointer-events: none;
      transition: 
        opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
        transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
        filter 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform, opacity, filter;
    }
    .panel-appear-active {
      opacity: 1 !important;
      transform: 
        translateX(0) 
        scale(1) 
        perspective(1000px) 
        rotateY(0deg) !important;
      filter: blur(0) !important;
      pointer-events: auto !important;
    }

    /* Добавляем стиль для overlay с размытием */
    #overlay {
      position: fixed;
      inset: 0;
      z-index: 400;
      opacity: 0;
      pointer-events: none;
      transition: opacity .4s cubic-bezier(.4,0,.2,1);
      background: linear-gradient(
        135deg,
        rgb(var(--base-color-rgb)/0.4),
        rgb(var(--shiftedLightWight-rgb)/0.2),
        rgb(var(--shiftedRightDark-rgb)/0.5)
      );
    }
    .overlay-blur {
      backdrop-filter: blur(8px);
      transition: 
        opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1),
        backdrop-filter 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }
    /* Добавляем эффект глубины для контента панели */
    .panel-content {
      transform-style: preserve-3d;
      perspective: 2000px;
    }
    .panel-item {
      transform: translateZ(0);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 0.75rem; /* rounded-xl */
      background-color: rgb(var(--white)/0.05); /* bg-white/5 */
      border-width: 1px; /* border */
      border-color: rgba(62, 49, 136, 0.3); /* border-indigo-700/30 */
      position: relative; /* relative */
      transition-property: all; /* transition-all */
      transition-duration: 0.2s; /* duration-200 */
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    .panel-item:hover {
      transform: translateZ(10px);
    }
    .color-input {
      appearance: none;
      width: 2.1em; height: 2.1em;
      border-radius: .8em; border: 2.2px solid rgba(167,139,250,0.22);
      box-shadow: 0 1.5px 5px 0 rgba(160,94,255,0.09) inset, 0 1.5px 8px 0 #fff2;
      cursor: pointer;
      background: linear-gradient(120deg,rgba(121,74,251,0.09),rgba(102,126,234,.14));
      transition: border .19s,box-shadow .19s,filter .19s,background .19s;
      outline: none;
      padding: 0; margin: 0; position: relative; z-index: 1;
    }
    .color-input:hover {
      border: 2.2px solid #a78bfa;
      box-shadow: 0 4px 18px 0 #a78bfa44, 0 1px 4px #fff5;
      filter: brightness(1.08) saturate(1.11);
      background: linear-gradient(112deg,#a78bfa22 0%,#f472b622 100%);
    }
    .color-input::-webkit-color-swatch { 
      border-radius: .7em; 
      border: none; 
      padding: 0;
    }
    .color-input::-moz-color-swatch { 
      border-radius: .7em; 
      border: none; 
      padding: 0;
    }
    .color-input:active { 
      filter: brightness(0.99);
    }
    .card-3d { 
      transition:box-shadow .25s,transform .22s,border-color .18s; 
      box-shadow: 0 2px 8px 0 #1b183c2b;
    }
    .card-3d:hover { 
      box-shadow:
        0 12px 44px rgb(var(--shedow-rgb)/0.6),
        0 2px 8px rgb(var(--shedow-rgb));
      transform: translateY(-4px) scale(1.015) rotateX(2deg) rotateY(-2deg); 
      border-color: rgb(var(--shedow-rgb)/.5); z-index: 2;
    }
    /* Кастомный чекбокс */
    .container-chekbox {
      cursor: pointer;
      width: auto !important;
    }
    .container-chekbox input {
      display: none;
    }
    .container-chekbox svg {
      overflow: visible;
    }
    label.container-chekbox,
    label.container-chekbox svg {
      color: rgb(var(--text-rgb));
    }
    .path-chekbox {
      fill: none;
      stroke: rgb(var(--text-rgb));
      stroke-width: 6;
      stroke-linecap: round;
      stroke-linejoin: round;
      transition: stroke-dasharray 0.5s ease, stroke-dashoffset 0.5s ease;
      stroke-dasharray: 241 9999999;
      stroke-dashoffset: 0;
    }
    .container-chekbox input:checked ~ svg .path-chekbox {
      stroke-dasharray: 70.5096664428711 9999999;
      stroke-dashoffset: -262.2723388671875;
    }
    /* Dropzone 3D hover */
    .dropzone {
      border: 1.7px dashed rgb(var(--tetrad-color1-rgb));
      background: linear-gradient(120deg, 
        rgb(var(--tetrad1-light-rgb)/0.12) 0%, 
        rgb(var(--tetrad1-dark-rgb)/0.07) 100%);
      border-radius: 1.1em;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2.1rem 1rem 1.6rem;
      margin-bottom: 1.3rem;
      margin-top: 0.5rem;
      position: relative;
      transition: all 0.3s ease-in-out;
      cursor: pointer;
      min-height: 130px;
      gap: 0.5rem;
    }
    .dropzone.dragover {
      transform: scale(1.02);
      border-color:  rgb(var(--shedow-rgb));
      box-shadow:
        0 12px 44px rgb(var(--shedow-rgb)/0.6),
        0 2px 8px rgb(var(--shedow-rgb)/0.8);
      background: linear-gradient(120deg, 
        rgb(var(--tetrad2-light-rgb)/0.22) 0%, 
        rgb(var(--tetrad2-dark-rgb)/0.18) 100%);
    }
    .dropzone .dz-icon {
      opacity: 0.83;
      font-size: 2.5rem;
    }
    .dropzone .dz-label {

      font-size: 1.13rem;
      font-weight: 500;
      margin-bottom: .2em;
      text-align: center;
    }
    .dropzone .dz-or {
      font-size: 0.9rem;
      margin: 0.3em 0;
      text-align: center;
    }
    .dropzone input[type="file"] {
      display: none;
    }
    .dropzone-3d {
      transition: box-shadow .22s, transform .16s; 
      box-shadow: 0 2px 10px 0 #a78bfa22;
    }
    .dropzone-3d:hover {
      box-shadow:
        0 6px 22px rgb(var(--shedow-rgb)/0.1),
        0 1px 4px rgb(var(--shedow-rgb)/0.2);
      transform: translateY(-3px) scale(1.03) rotateX(2deg) rotateY(-2deg);
      border-color:rgb(var(--tetrad-color2-rgb));
    }
    /* Состояние закрытого аккордиона */
    .accordion-disabled { 
      pointer-events: none; 
      opacity: 0.7; 
      filter: blur(1.5px);
    }
    /* Glass effect styles */
    .glass {
      background: linear-gradient(114deg,
        rgb(var(--base-color1)),
        rgb(var(--base-color2)) 90%
      );
      border: 1.5px solid rgba(120,86,255,.13);
      box-shadow: 0 18px 60px 0 rgba(60,30,90,0.22), 0 2px 8px 0 rgba(0,0,0,0.06);
      backdrop-filter: blur(10px) saturate(1.4);
    }
    /* Анимация для аккордеона - Старая */
    .accordion-header { cursor:pointer; user-select:none; }
    .accordion-header i,
    .accordion-header swg { 
      transition: transform 0.2s; 
    }
    .accordion-header.active i,
    .accordion-header.active swg {
      transform: rotate(90deg);
    }
    .accordion-content {
      overflow: hidden;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
      will-change: max-height, opacity;
    }
    .accordion-content.collapsing {
      transition: max-height 0.3s ease-in, opacity 0.3s ease-in;
    }
    #checkbox {
      display: none;
    }
    
    /* CSS стили для чекбоксов */
    .custom-checkbox-container {
      position: absolute;
      width: 22px;
      height: 28px;
      right: 20px;
      top: 16px ;
      user-select: none;
      pointer-events: none;
      color: rgb(var(--text-rgb));
    }

    .accordion-checkbox {
      position: absolute;
      opacity: 0;
      width: 1px;
      height: 1px;
      pointer-events: none;
    }
    .toggle {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition-duration: .5s;
      color: rgb(var(--text-rgb));
    }
    .bars {
      width: 100%;
      height: 2px;
      background-color: rgb(var(--text-rgb));
      border-radius: 2px;
    }
    #bar2 {
      transition-duration: .8s;
    }
    #bar1,
    #bar3 {
      width: 70%;
    }
    .accordion-checkbox:checked + .toggle .bars {
      position: absolute;
      transition-duration: .5s;
    }
    .accordion-checkbox:checked + .toggle #bar2 {
      transform: scaleX(0);
      transition-duration: .5s;
    }
    .accordion-checkbox:checked + .toggle #bar1 {
      width: 100%;
      transform: rotate(45deg);
      transition-duration: .5s;
    }
    .accordion-checkbox:checked + .toggle #bar3 {
      width: 100%;
      transform: rotate(-45deg);
      transition-duration: .5s;
    }
    .accordion-checkbox:checked + .toggle {
      transition-duration: .5s;
      transform: rotate(180deg);
    }
    /* Анимация для аккордеона - новая */
    /* Базовые стили аккордеона */
    .accordion .accordion-content {
      overflow: visible;
      max-height: 0;
      opacity: 0;
      transition: 
        max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1),
        opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: max-height, opacity;
    }
    /* Состояние открытого аккордеона */
    .accordion.accordion-open .accordion-content {
      opacity: 1;
    }
    /* Плавное появление контента */
    .accordion-content > * {
      transform: translateY(-10px);
      opacity: 0;
      transition: 
        transform 0.3s ease,
        opacity 0.3s ease;
    }
    .accordion.accordion-open .accordion-content > *:not(.dropIndicator) {
      transform: translateY(0);
      opacity: 1;
    }
    .tooltip-settings {
      position: absolute;
      bottom: 0%;
      right: 108%;
      /* Обновленный фон с градиентом */
      background: linear-gradient(
        90deg,
        rgb(var(--base-color-rgb)/0.1) 65%,
        rgb(var(--base-color-rgb)/0.85) 100%
      );
      /* Стеклянный эффект */
      backdrop-filter: blur(8px);
      /* Обновленная граница */
      border: 1px solid rgb(var(--white)/0.1);
      /* Тень для глубины */
      box-shadow: 
        0 4px 15px -3px rgb(var(--black)/0.3),
        0 2px 6px -2px rgb(var(--black)/0.2),
        inset 0 0 0 1px rgb(var(--white)/0.1);
      /* Базовые стили */
      color: rgb(var(--text-rgb)/0.9);
      padding: 0.5em 0.9em;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 400;
      letter-spacing: 0.01em;
      white-space: nowrap;
      /* Начальное состояние для анимации */
      opacity: 0;
      transform: 
        translateX(10px)
        translateY(5px)
        rotateX(-10deg)
        rotateY(10deg)
        scale(0.95);
      transform-origin: center right;
      /* Плавная анимация */
      transition: 
        opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
        transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
        backdrop-filter 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      /* Важные свойства */
      pointer-events: none;
      z-index: 1000;
    }
    /* Состояние при наведении на родительский элемент */
    .items-center:hover .tooltip-settings,
    input[type="color"]:hover ~ .tooltip-settings,
    input[type="range"]:hover ~ .tooltip-settings,
    select:hover ~ .tooltip-settings {
      opacity: 1;
      transform: 
        translateX(0)
        translateY(0)
        rotateX(0)
        rotateY(0)
        scale(1);
      backdrop-filter: blur(8px);
    }
    /* Добавляем небольшую стрелку */
    .tooltip-settings::after {
      content: '';
      position: absolute;
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
      border-style: solid;
      border-width: 6px 0 6px 6px;
      border-color: transparent transparent transparent rgb(var(--white)/0.1);
    }
    /* Показываем tooltip только при наведении на его родительский блок */
    .items-center:hover .tooltip-settings,
    input[type="color"]:hover ~ .tooltip-settings,
    input[type="range"]:hover ~ .tooltip-settings,
    select:hover ~ .tooltip-settings {
      opacity: 1;
      backdrop-filter: blur(15px);
      z-index: 2;
    }

    /* Стили для раздела настроек GRID */
    #dropIndicator{
      transform-origin:center;
      transition:opacity .3s cubic-bezier(.4,0,.2,1),transform .3s cubic-bezier(.4,0,.2,1)
    }
    .dropIndicator{
      position: absolute;
      left: 0.5rem; /* left-2 (1rem = 16px → 0.5rem = 8px) */
      right: 0.5rem;
      height: 2px; /* h-px — стандартная высота в 1 пиксель */
      background-image: linear-gradient(
        to right,
        rgb(var(--tetrad2-light-rgb)/0.6) 0%,
        rgb(var(--tetrad1-light-rgb)/0.7) 50%,
        rgb(var(--tetrad2-light-rgb)/0.6) 100%
      );
      border-radius: 9999px; /* rounded-full */
      opacity: 0;
      pointer-events: none;
    }
    .draggingSet{opacity:.35}
      tbody tr:not(.dammy-slot):hover{background:rgb(var(--shiftedRightDark-rgb)/0.08)}
      tbody tr:not(.dammy-slot):hover td{background:inherit}
    .dynamic-input{
      color:rgb(var(--text-rgb));
      transition:background .2s,box-shadow .35s,transform .3s
    }
    .dynamic-input::placeholder {
      color:rgb(var(--text-rgb)/0.3);
    }
    .dynamic-input.is-focused{
      background:radial-gradient(500px circle at var(--ix,50%) var(--iy,50%),rgb(var(--shiftedRightDark-rgb)/0.14),rgb(var(--scrollableTableH-rgb)/0.1) 30%,transparent 70%);
      box-shadow:inset 0 0 0 1px rgb(var(--scrollableTableB-rgb)/0.35),0 0 0 2px rgb(var(--dynamic-input-box-b)/0.2),0 4px 12px rgb(var(--black)/0.15);
      outline:none;
      transform:scale(1.012);
      color:#fff;
    }
    .ip-cell.is-empty{
      border-right:1px dashed rgb(var(--tetrad1-dark-rgb)/0.5);
      background:linear-gradient(90deg,transparent 0%,rgb(var(--tetrad1-dark-rgb)/0.12) 30%,rgb(var(--tetrad1-dark-rgb)/0.18) 55%,rgb(var(--tetrad1-dark-rgb)/0.24) 100%);
      background-size:200% 100%;
      animation:pulseEmptyGrad 3.4s ease-in-out infinite
    }
    .ip-cell.is-empty .dynamic-input{
      font-style:italic;
      color: rgb(var(--shedow-rgb));
      opacity: 0.85
    }
    .dammy-slot .dynamic-input{
      background:linear-gradient(110deg, rgb(var(--white)/0.04) 0%, rgb(var(--white)/0.1) 55%, rgb(var(--white)/0.04) 100%);
      background-size:200% 100%;
      animation:slotShimmer 8s ease-in-out infinite;
      font-style:italic;
      letter-spacing:.025em;
    }
    .modal-expanded{
      max-width:none;
      width:100%;
      height:100%;
      background: linear-gradient(135deg, rgb(var(--base-color1)/0.7) 0%, rgb(var(--base-color2)/0.7) 100%);
    }
    .camerasTableBody > :not([hidden]) ~ :not([hidden]) {
      margin-top: -1px; /* "схлопывание" бордеров */
      border-top: 1px solid rgb(var(--white)/0.05);
    }

    /* Стиль таблицы */
    .scrollable-table {
      max-height: 12rem;
      overflow-y: auto; 
      border-radius: 1rem;
      border-width: 1px;
      border-color: rgb(var(--white)/0.12);
      background-color: rgb(var(--white)/0.04);
      box-shadow: inset 0 2px 4px rgb(var(--black)/0.04);
      transition-property: height;
      transition-duration: 300ms;
      transition-timing-function: ease;
      width: 100%; 
    }
    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
    }
    thead tr.sticky, thead th.sticky {
      position: sticky;
      top: 0;
      z-index: 2;
    }
    .scrollable-table::-webkit-scrollbar{width:8px;height:8px}
    .scrollable-table::-webkit-scrollbar-thumb{background:linear-gradient(to bottom, rgb(var(--scrollableTableH-rgb)) 0%, rgb(var(--scrollableTableB-rgb)) 100%); border-radius:4px}
    .scrollable-table::-webkit-scrollbar-track{background:transparent}
    .sticky-header {
      position: sticky;
      top: 0;
      background-color: rgb(var(--stickyHeader-rgb)/0.8);
      backdrop-filter: blur(4px);
      color: rgb(var(--scrollableTableH-rgb)); 
      z-index: 10;
    }
    /* кнопка разварачивания интерфейса настроек камер */
    .openSettingsBtnModal {
      position: absolute;
      width: 20px;
      height: 28px;
      right: 56px;
      top: 16px ;
      color: rgb(var(--text-rgb));
      transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    /* Эффект свечения при наведении */
    .openSettingsBtnModal::before {
      inset: -2px;
      opacity: 0;
      z-index: -1;
      transition: opacity 1.2s ease;
    }
    .openSettingsBtnModal:hover {
      color: rgb(var(--white));
      transform: translateY(-1px);
      text-shadow: 0 0 8px rgb(var(--white)/0.7);
    }
    .openSettingsBtnModal:hover::before {
      opacity: 0.5;
    }
    .openSettingsBtnModal:hover svg,
    .openSettingsBtnModal:hover i {
      filter: drop-shadow(0 0 8px rgb(var(--white)/0.7));
      transform: rotate(180deg);
    }
    .openSettingsBtnModal svg,
    .openSettingsBtnModal i {
      transition: transform 1.6s ease, filter 0.3s ease;
    }
    .openSettingsBtnModal:active {
      transform: translateY(1px) scale(0.98);
    }
    /* Скрываем кнопку, если аккордеон mainSectionWrap закрыт */
    #mainSectionWrap:not(.accordion-open) #openSettingsBtnModal {
      opacity: 0;
      visibility: hidden;
    }
    #mainSectionWrap.accordion-open #openSettingsBtnModal {
      opacity: 1;
      visibility: visible;
    }
    /* Индикатор Drag and Drop */
    .handle {
      color: rgb(var(--stickyHeader-rgb));
    }

    .custom-range {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      background: transparent;
    }

    /* Трек */
    .custom-range::-webkit-slider-runnable-track {
      width: 100%;
      height: 6px;
      background: linear-gradient(90deg,
        rgb(var(--tetrad2-light-rgb)) 0%,
        rgb(var(--tetrad2-dark-rgb)) 100%
      );
      border-radius: 999px;
    }

    /* Thumb (ползунок) */
    .custom-range::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgb(var(--tetrad-color2-rgb));
      cursor: pointer;
      margin-top: -6px; /* Центрируем относительно трека */
    }

    /* Для Firefox */
    .custom-range::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgb(var(--tetrad-color2-rgb));
      cursor: pointer;
      border: none;
    }

    .custom-range::-moz-range-track {
      width: 100%;
      height: 6px;
      background: linear-gradient(90deg,
        rgb(var(--tetrad2-light-rgb)) 0%,
        rgb(var(--tetrad2-dark-rgb)) 100%
      );
      border-radius: 999px;
    }


    .anim-border{
      position:relative;
      padding: 2.2rem 0rem 5rem 0rem;
      z-index: 1;
      background: rgb(var(--stickyHeader-rgb)/0.4);

    }
    .anim-border:before{
      content:"";
      position:absolute;
      background-size:1000% 1000%;
      pointer-events:none;
    }

    .icon-pulse svg{animation:pulseGlow 3s ease-in-out infinite;}

    .text-white-castom,
    .text-white-castom svg,
    .text-white-castom i {
      color: rgb(var(--text-rgb));
    }
    .text-whiteW1-castom,
    .text-whiteW1-castom svg,
    .text-whiteW1-castom i {
      color: rgb(var(--textW1-rgb));
    }
    .text-white-castom-80,
    .text-white-castom-80 svg,
    .text-white-castom-80 i {
      color: rgb(var(--text-rgb)/0.7);
    }
    input.text-white-castom,
    select.text-white-castom {
      color: rgb(var(--white));
    }
    #loaderOverlay {
      z-index: 999;
      background-color: #111;
      transition: background-color 2.5s ease;
    }

    /* Слово автомагически */ 
    .magick-text {
      position: relative;
      transition: all 0.4s ease;
    }

    .magick-text:active {
      transform: scale(0.96);
    }

    .magick-text:before,
    .magick-text:after {
      position: absolute;
      content: "";
      width: 150%;
      left: 50%;
      height: 100%;
      transform: translateX(-50%);
      z-index: -1000;
      background-repeat: no-repeat;
    }

    .magick-text:hover:before {
      top: -70%;
      background-image: radial-gradient(circle, #a89215 20%, transparent 20%),
        radial-gradient(circle, transparent 20%, #13a5be 20%, transparent 30%),
        radial-gradient(circle, #a3b82d 20%, transparent 20%),
        radial-gradient(circle, #590cbe 20%, transparent 20%),
        radial-gradient(circle, transparent 10%, #bd1717 15%, transparent 20%),
        radial-gradient(circle, #2a7ce8 20%, transparent 20%),
        radial-gradient(circle, #30e82a 20%, transparent 20%),
        radial-gradient(circle, #e92c75 20%, transparent 20%),
        radial-gradient(circle, #914fe7 20%, transparent 20%);
      background-size: 10% 10%, 20% 20%, 15% 15%, 20% 20%, 18% 18%, 10% 10%, 15% 15%,
        10% 10%, 18% 18%;
      background-position: 50% 120%;
      animation: greentopBubbles 0.6s ease;
    }

    .magick-text:hover::after {
      bottom: -70%;
      background-image: radial-gradient(circle, #ff93db 20%, transparent 20%),
        radial-gradient(circle, #2ae8df 20%, transparent 20%),
        radial-gradient(circle, transparent 10%, #71ffbd 15%, transparent 20%),
        radial-gradient(circle, #2a9ce8 20%, transparent 20%),
        radial-gradient(circle, #7814fc 20%, transparent 20%),
        radial-gradient(circle, #73e4f8 20%, transparent 20%),
        radial-gradient(circle, #f8d3a9 20%, transparent 20%);
      background-size: 15% 15%, 20% 20%, 18% 18%, 20% 20%, 15% 15%, 20% 20%, 18% 18%;
      background-position: 50% 0%;
      animation: greenbottomBubbles 0.6s ease;
    }




    .scrollbar-thin::-webkit-scrollbar {
      width: 7px;
    }
    .scrollbar-thin::-webkit-scrollbar-thumb {
      background: linear-gradient(120deg, rgb(var(--scrollableTableH-rgb)) 40%, rgb(var(--scrollableTableB-rgb)) 100%);
      border-radius: 8px;
    }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-thumb { background: #bdbdbd44; border-radius: 8px;}

    /*** Анимации  ***/
    @keyframes pulseEmptyGrad{
      0%{background-position:0 0}
      50%{background-position:100% 0}
      100%{background-position:0 0}}
    @keyframes slotShimmer{
      0%{background-position:-150% 0}
      50%{background-position:150% 0}
      100%{background-position:-150% 0}}
    .animate-row-in3d{animation:rowIn3d .55s cubic-bezier(.4,0,.2,1)}
    @keyframes rowIn3d{
      0%{opacity:0;transform:perspective(600px) rotateX(-6deg) translateY(24px)}
      100%{opacity:1;transform:none}}
    .animate-row-out{animation:rowOut .3s cubic-bezier(.4,0,.2,1) forwards}
    @keyframes rowOut{
      0%{opacity:1}
      100%{opacity:0;transform:translateY(12px)}}
    .animate-pulse-slow{animation:pulseSlow 7s ease-in-out infinite}
    @keyframes pulseSlow{0%,100%{opacity:.35}50%{opacity:.55}}
    .animate-bounce-slow {
      animation: bounce 3s ease-in-out infinite;}
    @keyframes bounce {
      0%, 100% { transform: translateY(0);}
      50% { transform: translateY(-10px);}}
    .animate-gradient-slow {background-size: 400% 400%; animation: gradient-shift 8s ease infinite;}
    @keyframes gradient-shift {
      0% { background-position: 0% 50%;}
      50% { background-position: 100% 50%;}
      100% { background-position: 0% 50%;}}
    @keyframes fadeInTooltip { 
      0% { opacity: 0; transform: translateX(-50%) scale(0.93) translateY(8px);} 
      100% { opacity: 1; transform: translateX(-50%) scale(1);}}
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px);} 
      to   { opacity: 1; transform: translateY(0);}}
    @keyframes pulse-offline { 
      0% { box-shadow: 0 0 11px #f87171aa, 0 0 2px #fca5a577, 0 0 2.5px #fff9;} 
      70% { box-shadow: 0 0 18px #f87171dd, 0 0 8px #fca5a5cc, 0 0 3.5px #fff9;} 
      100% { box-shadow: 0 0 11px #f8717188, 0 0 2px #fca5a544, 0 0 2.5px #fff9;}}
    @keyframes pulse-warning {
      0% { box-shadow: 0 0 11px #fbbf24aa, 0 0 2px #fde68a77, 0 0 2.5px #fff9;}
      70% { box-shadow: 0 0 18px #fbbf24dd, 0 0 8px #fde68acc, 0 0 3.5px #fff9;}
      100% { box-shadow: 0 0 11px #fbbf2488, 0 0 2px #fde68a44, 0 0 2.5px #fff9;}}
    @keyframes pulse-online { 
      0% { box-shadow: 0 0 11px #34d399aa, 0 0 2px #a7f3d0aa, 0 0 2.5px #fff9;} 
      75% { box-shadow: 0 0 18px #34d399cc, 0 0 8px #a7f3d0cc, 0 0 3.5px #fff9;} 
      100% { box-shadow: 0 0 11px #34d39977, 0 0 2px #a7f3d055, 0 0 2.5px #fff9;}}
    @keyframes pulse-initial {
      0% { box-shadow: 0 0 11px #6b7280aa, 0 0 2px #9ca3afaa, 0 0 2.5px #fff9; }
      75% { box-shadow: 0 0 18px #6b7280cc, 0 0 8px #9ca3afcc, 0 0 3.5px #fff9; }
      100% { box-shadow: 0 0 11px #6b728077, 0 0 2px #9ca3af55, 0 0 2.5px #fff9; }}
    @keyframes pulse-glow-off { 
      0% { opacity: 0.2; transform: scale(0.92);} 
      76% { opacity: 0.4; transform: scale(1.11);} 
      100% { opacity: 0.1; transform: scale(0.92);}}
    .notification.wave-out {animation: waveOut 0.6s ease-in-out forwards;}
    @keyframes waveOut { 
      0% { transform: translateX(6%) scale(0.93);} 
      100% { transform: translateX(100%) scale(0.8); opacity: 0;}}
    .notification.fade-out-up {animation: fadeOutUp 0.6s ease-in-out forwards;}
    @keyframes fadeOutUp { 
      0% { transform: translateX(6%) scale(0.93);}
      100% { transform: translateX(100%) scale(0.8); opacity: 0;}}
    @keyframes notif-in {
      0% { opacity: 0; transform: translateY(36px) scale(0.98); filter: blur(10px);}
      60% { opacity: 1; transform: translateY(-6px) scale(1.04); filter: blur(2px);}
      100% { opacity: 1; transform: translateY(0px) scale(1); filter: blur(0);}}
    .notif-leave {animation: notif-out 0.35s cubic-bezier(.4,0,.2,1) forwards; will-change: opacity, transform, filter;}
    @keyframes notif-out {
      to { opacity: 0; transform: translateY(34px) scale(0.97); filter: blur(10px);}}
    .animate-fade-in {animation: fade-in 0.2s ease-out forwards;}
    @keyframes fade-in { /* Окно помощи */
      from { opacity: 0; transform: scale(0.95);}
      to { opacity: 1; transform: scale(1);}}
    @keyframes spin_4991 { /* Агимация закрузки */
      10% { -webkit-transform: translateY(-102%); transform: translateY(-102%);}
      25% { -webkit-transform: translateY(-100%); transform: translateY(-100%);}
      35% { -webkit-transform: translateY(-202%); transform: translateY(-202%);}
      50% { -webkit-transform: translateY(-200%); transform: translateY(-200%);}  
      60% { -webkit-transform: translateY(-302%); transform: translateY(-302%);}
      75% { -webkit-transform: translateY(-300%); transform: translateY(-300%);}
      85% { -webkit-transform: translateY(-402%); transform: translateY(-402%);}
      100% { -webkit-transform: translateY(-400%); transform: translateY(-400%);}}
    .modal-fade-in {animation: modal-fade-in .33s cubic-bezier(.4,0,.2,1);}
    @keyframes modal-fade-in {
      0% { opacity: 0; transform: translateY(32px) scale(.97);}
      55% { opacity: 1; transform: translateY(-4px) scale(1.01);}
      100% { opacity: 1; transform: translateY(0) scale(1);}}
    .modal-fade-out {animation: modal-fade-out .33s cubic-bezier(.4,0,.2,1);}
    @keyframes modal-fade-out {
      0% { opacity: 1; transform: translateY(0) scale(1);}
      90% { opacity: 0; transform: translateY(32px) scale(.97);}
      100% { opacity: 0; transform: translateY(32px) scale(.97);}}
    .expand-icon:hover i, .expand-icon:hover svg {animation: pulse-expand 1.2s infinite cubic-bezier(.4,0,.2,1);}
    @keyframes pulse-expand {
      0% { transform: scale(1);}
      50% { transform: scale(1.15);}
      100% { transform: scale(1);}}
    .manage-icon:hover i, .manage-icon:hover svg {animation: rotate-gear 3s linear infinite;}
    @keyframes rotate-gear {
      from { transform: rotate(0deg);}
      to { transform: rotate(360deg);}}
    @keyframes inner-pulse {
      0% { box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.4), 0 8px 24px rgb(var(--black)/0.25);}
      50% { box-shadow: inset 0 0 0 2px rgba(255, 200, 0, 0.6), 0 8px 24px rgb(var(--black)/0.3);}
      100% { box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0.4), 0 8px 24px rgb(var(--black)/0.25);}}
    @keyframes gradient-shift {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    @keyframes greentopBubbles {
      0% {background-position: 5% 90%, 10% 90%, 10% 90%, 15% 90%, 25% 90%, 25% 90%, 40% 90%, 55% 90%, 70% 90%;}
      50% {background-position: 0% 80%, 0% 20%, 10% 40%, 20% 0%, 30% 30%, 22% 50%, 50% 50%, 65% 20%, 90% 30%;}
      100% {background-position: 0% 70%, 0% 10%, 10% 30%, 20% -10%, 30% 20%, 22% 40%, 50% 40%, 65% 10%, 90% 20%;
        background-size: 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%;}}
    @keyframes greenbottomBubbles {
      0% {background-position: 10% -10%, 30% 10%, 55% -10%, 70% -10%, 85% -10%, 70% -10%, 70% 0%;}
      50% {background-position: 0% 80%, 20% 80%, 45% 60%, 60% 100%, 75% 70%, 95% 60%, 105% 0%;}
      100% {background-position: 0% 90%, 20% 90%, 45% 70%, 60% 110%, 75% 80%, 95% 70%, 110% 10%;
        background-size: 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%, 0% 0%;}}
    
  </style>
</head>
<body>
<!-- LOADER -->
<div id="loaderOverlay" class="fixed inset-0 flex items-center justify-center z-1 transition-opacity duration-500">
  <div class="card">
    <div class="loader">
      <p>загружаем</p>
      <div class="words">
        <span class="word">виды с камер</span>
        <span class="word">красочный интерфейс</span>
        <span class="word">функции по одной</span>
        <span class="word">красивый градиент</span>
        <span class="word">виды с камер</span>
      </div>
    </div>
  </div>
</div>
<!-- TOOLBAR -->
<div id="toolbar" class="flex gap-2">
  <button id="refreshCamerasBtn"
    class="action-icon glass-btn p-1.5 flex items-center justify-center group" aria-label="Обновить">
    <span class="relative flex items-center justify-center">
      <i class="fas fa-sync-alt text-lg"></i>
    </span>
    <span class="custom-tooltip">Обновить камеры</span>
  </button>
  <button id="savePositionBtn"
    class="action-icon glass-btn p-1.5 flex items-center justify-center group" aria-label="Сохранить">
    <span class="relative flex items-center justify-center">
      <i class="fas fa-save text-lg"></i>
    </span>
    <span class="custom-tooltip">Сохранить расположение элементов</span>
  </button>
  <button id="helpBtn"
    class="action-icon glass-btn p-1.5 flex items-center justify-center group" aria-label="Помощь">
    <span class="relative flex items-center justify-center">
      <i class="fas fa-info-circle text-lg"></i>
    </span>
    <span class="custom-tooltip">Инструкция</span>
  </button>
  <button id="openSettingsBtn"
    class="action-icon glass-btn p-1.5 flex items-center justify-center group" aria-label="Настройки">
    <span class="relative flex items-center justify-center">
      <i class="fas fa-cog text-lg"></i>
    </span>
    <span class="custom-tooltip">Открыть настройки</span>
  </button>
</div>
  <!-- HEADER -->
  <header id="mainHeader" class="relative">
    <div id="mainInterfaceContainer" class="mx-auto w-full max-w-6xl">
      <div id="headerBar"
        class="flex items-center justify-between px-6 py-4 backdrop-blur rounded-b-xl shadow-lg transition">
        <h1 id="headerTitle" class="text-2xl md:text-3xl font-semibold text-white-castom tracking-wide">Активные принтера</h1>
        <div id="toolbarContainer"></div>
      </div>
    </div>
  </header>
  <!-- CAMERAS GRID -->
  <main class="flex-1 flex flex-col items-center w-full pb-4 pt-2">
    <div id="mainInterfaceContainerCameras" class="mx-auto w-full max-w-6xl">
      <div id="cameraContainer"
        class="grid gap-6 mt-6"
        style="grid-template-columns: repeat(3, minmax(0, 1fr));">
        <!-- Cameras rendered here -->
      </div>
    </div>
  </main>
  <!-- NOTIFICATIONS -->
  <div id="notificationContainer"
    class="fixed bottom-6 right-6 flex flex-col items-end gap-3 z-40"></div>
  <div id="notificationActions" class="hidden flex gap-2">
    <button id="expandNotificationsBtn"
      class="text-white-castom bg-white/10 hover:bg-white/20 text-white-castom/80 rounded-lg px-4 py-2 font-medium text-sm transition outline-none border border-white/10 backdrop-blur-lg">
      <i data-lucide="chevron-up" class="inline w-4 h-4 mr-1 -mt-0.5"></i> Развернуть стек
    </button>
    <button id="closeAllNotificationsBtn"
      class="text-white-castom bg-white/10 hover:bg-white/20 text-white-castom/80 rounded-lg px-4 py-2 font-medium text-sm transition outline-none border border-white/10 backdrop-blur-lg">
      <i data-lucide="x" class="inline w-4 h-4 mr-1 -mt-0.5"></i> Закрыть все
    </button>
  </div>
    <!-- Модальное окно настроек GRID -->
  <div id="settingsModal" class="fixed inset-0 z-800 hidden">
    <div class="absolute inset-0 backdrop-blur-lg" aria-hidden="true"><!-- Оверлей --></div>
    <div id="modalHolder" class="relative flex items-start justify-center p-6 w-full h-full overflow-auto"><!-- Сюда мы будем телепортировать окно настроек GRID --></div>
  </div>
  <!-- МЕНЮ НАСТРОЕК -->
  <aside id="settingsPanel"
    class="settings-panel panel-appear">
    <div class="panel-content">
      <div class="settings-panel-header">
        <h2 class="text-2xl font-semibold tracking-tight flex items-center gap-3 text-white-castom drop-shadow-sm">
          <i data-lucide="sliders" class="w-7 h-7 text-white-castom drop-shadow"></i>
          Настройки
        </h2>
        <button id="closeSettingsBtn" aria-label="Закрыть настройки" class="close-btn-fancy glass-btn p-2.5 transition outline-none accordion-toggle">
          <i data-lucide="x" class="w-7 h-7"></i>
        </button>
        <!-- УВЕДОМЛЕНИЕ О НЕПРИМЕНЁННЫХ ИЗМЕНЕНИЯХ -->
        <div id="settingsChangedNotification"
          class="hidden px-8 py-7 rounded-lg shadow-lg text-white-castom text-lg font-medium flex items-center justify-between transform duration-300">
          <span>Примените настройки через кнопку внизу меню, чтобы избежать системных ошибок</span>
          <button id="closeNotificationBtn" aria-label="Закрыть настройки" class="close-btn-fancy glass-btn p-2.5 transition outline-none accordion-toggle">
            <i data-lucide="x" class="w-7 h-7"></i>
          </button>
        </div>
      </div>
    </div>
    <div class="px-8 py-7 space-y-6">
      <!-- Аккордион -->
      <div class="space-y-3" id="accordionList">
        <!-- Цветовая схема (accordion) -->
        <div class="panel-item card-3d accordion">
          <button type="button" class="w-full flex items-center justify-between px-5 py-4 font-semibold text-lg tracking-tight accordion-toggle" aria-expanded="true" tabindex="0">
            <span class="flex items-center gap-3">
              <i data-lucide="palette" class="w-7 h-7 text-white-castom"></i>
              <span class="text-white-castom-80">Цветовая схема</span>
            </span>
              <div class="custom-checkbox-container">
                <input type="checkbox" id="accordion-checkbox-theme" class="accordion-checkbox">
                <label for="accordion-checkbox-theme" class="toggle">
                  <div class="bars" id="bar1"></div>
                  <div class="bars" id="bar2"></div>
                  <div class="bars" id="bar3"></div>
                </label>
              </div>
          </button>
           <div class="accordion-content px-5 pb-5 pt-0" data-accordion-content="theme">
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Основные цвета:</span>
              <input id="color1" type="color" value="#667eea" class="color-input" aria-describedby="tip-color1" />
              <input id="color2" type="color" value="#764ba2" class="color-input" aria-describedby="tip-color2" />
              <span class="tooltip-settings" id="tip-color1">
                <span style="font-size: 1rem;"> <p>Командный пункт цветов</p> </span>
                <p> Здесь живут <strong>главные оттенки</strong> — ваши <em>«генералы»</em>.</p>
                <p> Меняете их — <strong>вся армия интерфейса</strong> мгновенно переодевается в новые цвета.</p>
                <p>💡 <i>Совет: Не трогайте алый, если не готовы к революции в дизайне.</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Смещение оттенков:</span>
              <input id="colorIntOver" type="range" min="1" max="3" step="0.1" value="1.6" class="flex-1 custom-range" aria-describedby="tip-colorIntOver" />
              <span class="tooltip-settings" id="tip-colorIntOver">
                <span style="font-size: 1rem;">
                  <p>Центр управления цветовой вселенной</p>
                </span>
                <p>Здесь рождаются <strong>ключевые оттенки</strong> — <em>ваши "цветовые монархи"</em>.</p>
                <p>Меняйте их смело — <strong>вся палитра интерфейса</strong> мгновенно перекрасится в унисон.</p>
                <p>🎨 <i>Совет: Ползунок влево — быстрый путь в темные века интерфейса. Не увлекайтесь!</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Ширина поля:</span>
              <input type="range" id="interfaceWidth" min="800" max="1920" value="1400" step="5" class="w-3/5 custom-range" aria-describedby="tip-interfaceWidth">
              <input id="interfaceWidthInput" type="number" min="800" max="1920" value="1400" class="w-16 rounded-lg border px-1 py-1 bg-[rgb(var(--stickyHeader-rgb)/0.7)] text-white-castom font-medium outline-none transition" aria-describedby="tip-interfaceWidth">
              <span id="interfaceWidthValue" class="text-white-castom">px</span>
              <span class="tooltip-settings" id="tip-notificationOpacity">
                <span style="font-size: 1rem;">
                  <p>Широта мысли и интерфейса</p>
                </span>
                <p>Задайте комфортные рамки: <strong>от 800px</strong> (минимум) до <strong>1920px</strong> (максимум).</p>
                <p><em>Но предупреждаем: если ваш монитор уже выбранного минимума</em>, <strong>ползунок вправо</strong> просто забастует!</p>
                <p>📏 <i>Совет: Хотите больше ширины? Придется купить больше монитор. Увы, ползунок не волшебник!</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Плохие уведомления:</span>
              <input id="errorNotificationColor" type="color" value="#ff4d4d" class="color-input" aria-describedby="tip-errorNotificationColor" />
              <span class="tooltip-settings" id="tip-errorNotificationColor">
                <span style="font-size: 1rem;">
                  <p>Сигнальный цвет для "беглых" принтеров</p>
                </span>
                <p>Задайте <strong>тревожный оттенок</strong> для уведомлений о <em>ненайденных 3D-принтерах</em>.</p>
                <p>Этот цвет будет кричать: <strong>"Эй, меня забыли подключить!"</strong> в вашем интерфейсе.</p>
                <p>🖨️ <i>Совет: Ярко-алый — для паники, нежно-мятный — для вежливого напоминания. Выбор за вами!</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Хорошие уведомления:</span>
              <input id="systemNotificationColor" type="color" value="#4ade80" class="color-input" aria-describedby="tip-systemNotificationColor" />
              <span class="tooltip-settings" id="tip-systemNotificationColor">
                <span style="font-size: 1rem;">
                  <p>Цвет успеха</p>
                </span>
                <p>Задайте <strong>победный оттенок</strong> для уведомлений о <em>подключенных 3D-принтерах</em> и <em>удачных операциях</em>.</p>
                <p>Этот цвет будет тихо ликовать: <strong>"Всё работает! Можно расслабиться!"</strong></p>
                <p>🎉 <i>Совет: Зеленый — для спокойных профессионалов, золотой — для тех, кто любит чувствовать себя победителем!</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 col-span-2 relative mb-2">
              <span class="w-44 text-white-castom">Прозрачность увед.:</span>
              <input id="notificationOpacity" type="range" min="0" max="1" step="0.05" value="0.3" class="flex-1 custom-range" aria-describedby="tip-notificationOpacity" />
              <span class="tooltip-settings" id="tip-notificationOpacity">  
                <span style="font-size: 1rem;">
                  <p>Регулятор "степени призрачности" уведомлений</p>
                </span>
                <p>Настройте <strong>прозрачность всех уведомлений</strong> — от <em>кричаще-явных</em> до <em>едва заметных шепотов</em>.</p>
                <p>Чем левее ползунок, тем больше ваши алерты будут напоминать <strong>интерфейсное привидение</strong>.</p>
                <p>👻 <i>Совет: 0% прозрачность = 0% видимости. Не удивляйтесь, если уведомления начнут исчезать!</i></p>
              </span>
            </div>
          </div>
        </div>
        <!-- LOADER SETTINGS -->
        <div class="panel-item card-3d accordion">
          <button type="button" class="w-full flex items-center justify-between px-5 py-4 font-semibold text-lg tracking-tight accordion-toggle" aria-expanded="true" tabindex="0">
            <span class="flex items-center gap-3">
              <i data-lucide="loader" class="w-7 h-7 text-white-castom"></i>
              <span class="text-white-castom-80">Загрузка</span>
            </span>
              <div class="custom-checkbox-container">
                <input type="checkbox" id="accordion-checkbox-loader" class="accordion-checkbox">
                <label for="accordion-checkbox-loader" class="toggle">
                  <div class="bars" id="bar1"></div>
                  <div class="bars" id="bar2"></div>
                  <div class="bars" id="bar3"></div>
                </label>
              </div>
          </button>
          <div class="accordion-content px-5 pb-5 pt-0" data-accordion-content="loader">
            <div class="flex items-center gap-3 relative mb-2">
              <label class="container-chekbox">
                <input id="offFullCheckbox" type="checkbox" />
                <svg viewBox="0 0 64 64" height="1em" width="1em">
                  <path d="M 0 16 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 16 L 32 48 L 64 16 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 16" pathLength="575.0541381835938" class="path-chekbox"></path>
                </svg>
              </label>
              <span class="w-36 text-white-castom">потокоотключение</span>
              <span class="tooltip-settings" id="tip-disable-animation">
                <p style="font-size: 1rem;"><strong>Режим энергоэффективности видео</strong> ⚡</p>
                <p>Активируйте <strong>автоотключение потоков</strong> <em>(от "постоянного наблюдения" до "турбо-режима загрузки")</em>.</p> <p>Включено - страницы Klipper открываются мгновенно. Выключено - видео работает без перерывов, как кинотеатр для трудоголиков.</p> <p>⚠️ <i>Особенность: Закрытие интерфейса Klipper вызывает кратковременное состояние неопределенности у индикаторов принтеров (пока идет процесс переподключения). Как только переподключение завершится успешно, индикаторы автоматически вернутся в нормальное состояние.</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <label class="container-chekbox">
                <input id="hideLoaderCheckbox" type="checkbox" />
                <svg viewBox="0 0 64 64" height="1em" width="1em">
                  <path d="M 0 16 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 16 L 32 48 L 64 16 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 16" pathLength="575.0541381835938" class="path-chekbox"></path>
                </svg>
              </label>
              <span class="w-36 text-white-castom">скрыть лоадер</span>
              <span class="tooltip-settings" id="tip-disable-animation">
                <p style="font-size: 1rem;"><strong>Экспресс-режим</strong> ⚡</p>
                <p>Галочка здесь — как красная кнопка в голливудском фильме: <strong>мгновенно отключает</strong> анимацию загрузки.</p>
                <p>Для тех, кто считает секунды <em>(или просто ненавидит крутящиеся шарики)</em>.</p>
                <p>💡 <i>Совет: включите, если ваш компьютер думает, что он - сонная улитка</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-36 text-white-castom">Цвет фона:</span>
              <input id="loaderBgColor" type="color" value="#111111" class="color-input" aria-describedby="tip-loaderBgColor" />
              <span class="tooltip-settings" id="tip-loaderBgColor">
                <span style="font-size: 1rem;"><p>Офисный дресс-код для загрузки 👔</p></span>
                  <p>Выберите <strong>цвет фона</strong>, в котором анимация будет выглядеть солидно <em>и по-деловому</em>.</p>
                  <p>Потому что даже загрузка должна соответствовать корпоративному стилю (и вашему настроению).</p>
                  <p>🎨 <i>Совет: серый — для серьёзных отчетов, радужный — для пятничных настроений</i></p>
                </span>
            </div>
            <div class="flex items-center gap-3 relative">
              <span class="w-36 text-white-castom">Прозрачность:</span>
              <input id="loaderOpacity" type="range" min="0" max="1" step="0.05" value="1" class="flex-1 custom-range" aria-describedby="tip-loaderOpacity" />
              <span class="tooltip-settings" id="tip-loaderOpacity">
                <span style="font-size: 1rem;"><p>Регулятор "Призрачной работы" 👻</p></span>
                <p>Здесь вы определяете <strong>степень невидимости</strong> подложки при загрузке <em>(от "ясно как день" до "исчез как бонусы в кризис")</em>.</p>
                <p>Чем левее ползунок — тем прозрачнее ваша загрузка. Правее — заметнее, чем опоздание на планерку.</p>
                <p>👁️ <i>Совет: 70% — золотая середина между "вижу процесс" и "не режет глаза"</i></p>
              </span>
            </div>
          </div>
        </div>
        <!-- HEADER SETTINGS -->
        <div class="panel-item card-3d accordion">
          <button type="button" class="w-full flex items-center justify-between px-5 py-4 font-semibold text-lg tracking-tight accordion-toggle" aria-expanded="true" tabindex="0">
            <span class="flex items-center gap-3">
              <i data-lucide="type" class="w-7 h-7 text-white-castom"></i>
              <span class="text-white-castom-80">Шапка интерфейса</span>
            </span>
              <div class="custom-checkbox-container">
                <input type="checkbox" id="accordion-checkbox-header" class="accordion-checkbox">
                <label for="accordion-checkbox-header" class="toggle">
                  <div class="bars" id="bar1"></div>
                  <div class="bars" id="bar2"></div>
                  <div class="bars" id="bar3"></div>
                </label>
              </div>
          </button>
          <div class="accordion-content px-5 pb-5 pt-0" data-accordion-content="header">
            <div class="flex items-center gap-3 relative mb-2">
              <label class="container-chekbox">
                <input id="hideHeaderCheckbox" type="checkbox" aria-describedby="tip-headerchekbox" />
                <svg viewBox="0 0 64 64" height="1em" width="1em">
                  <path d="M 0 16 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 16 L 32 48 L 64 16 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 16" pathLength="575.0541381835938" class="path-chekbox"></path>
                </svg>
              </label>
              <span class="text-white-castom">Скрыть заголовок</span>
                <span class="tooltip-settings" id="tip-tip-headerchekbox">
                  <span style="font-size: 1rem;"><p>Скрыть верхнюю панель</p></span>
                  <p>Отметьте галочкой, чтобы <strong>полностью убрать заголовок</strong> <em>(вместе со всеми кнопками на нём)</em>.</p>
                  <p>Как будто убрали табличку с названием офиса - пространство становится чище.</p>
                  <p>👌 <i>Совет: включайте, когда нужно больше места для основной работы</i></p>
                </span>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-36 text-white-castom">Текст:</span>
              <input id="headerText" type="text" value="Активные принтера"
                class="w-full rounded-lg border px-3 py-1.5 bg-[rgb(var(--stickyHeader-rgb)/0.7)] text-white-castom font-medium placeholder-slate-400 outline-none transition"
                placeholder="Текст заголовка" aria-describedby="tip-headerText" />
              <span class="tooltip-settings" id="tip-headerText">
                <span style="font-size: 1rem;"><p>Визитная карточка системы</p></span>
                <p>Назначьте <strong>главный заголовок</strong>, который будет встречать пользователей <em>(как табличка на двери вашего кабинета)</em>.</p>
                <p>Может быть строгим "Операционный центр" или душевным "Командный пункт №1" - выбор за вами!</p>
                <p>💼 <i>Совет: используйте 2-3 слова, которые сразу передают суть системы</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-36 text-white-castom">Цвет текста:</span>
              <input id="headerTextColor" type="color" value="#ffffff" class="color-input" aria-describedby="tip-headerTextColor" />
              <span class="tooltip-settings" id="tip-headerTextColor">
                <span style="font-size: 1rem;"><p>Костюм для заголовка 👔</p></span>
                <p>Выберите <strong>цвет оформления</strong> для верхней части системы <em>(как подбираете галстук к костюму)</em>.</p>
                <p>Синий для солидности, красный для срочности, зелёный для роста - цвет влияет на восприятие!</p>
                <p>🎨 <i>Совет: используйте корпоративные цвета, чтобы заголовок выглядел "по-деловому"</i></p></span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-36 text-white-castom">Фон:</span>
              <input id="headerBgColor" type="color" value="#000000" class="color-input" aria-describedby="tip-headerBgColor" />
              <span class="tooltip-settings" id="tip-headerBgColor">
                <span style="font-size: 1rem;"><p>Обои для заголовка страницы🖼️</p></span>
                <p>Выберите <strong>фоновый цвет</strong> для шапки системы <em>(как выбираете обивку для кресла в кабинете)</em>.</p>
                <p>Светлый для элегантности, тёмный для драматизма, цветной - чтобы выделиться на фоне конкурентов.</p>
                <p>🎭 <i>Совет: контрастный фон сделает заголовок читаемым как отчёт перед советом директоров</i></p></span>
            </div>
            <div class="flex items-center gap-3 relative">
              <span class="w-36 text-white-castom">Прозрачность:</span>
              <input id="headerBgOpacity" type="range" min="0" max="1" step="0.05" value="0.4" class="flex-1 custom-range" aria-describedby="tip-headerBgOpacity" />
              <span class="tooltip-settings" id="tip-headerBgOpacity">
                <span style="font-size: 1rem;"><p>Режим "Стеклянный офис" 🪟</p></span>
                <p>Регулируйте <strong>прозрачность фона заголовка</strong> <em>(от "невидимый как идеи на планерке" до "солидный как годовой отчёт")</em>.</p>
                <p>Чем левее ползунок - тем призрачнее фон. Правее - основательнее выглядит шапка.</p>
                <p>🔍 <i>Совет: 70% - идеальный баланс между стилем и читаемостью текста</i></p>
              </span>
            </div>
          </div>
        </div>
        <!-- GRID -->
        <div class="panel-item card-3d accordion">
          <button type="button" class="w-full flex items-center justify-between px-5 py-4 font-semibold text-lg tracking-tight accordion-toggle" aria-expanded="true" tabindex="0">
            <span class="flex items-center gap-3">
              <i data-lucide="layout-grid" class="w-7 h-7 text-white-castom"></i>
              <span class="text-white-castom-80" >Сетка камер</span>
            </span>
              <div class="custom-checkbox-container">
                <input type="checkbox" id="accordion-checkbox-grid" class="accordion-checkbox">
                <label for="accordion-checkbox-grid" class="toggle">
                  <div class="bars" id="bar1"></div>
                  <div class="bars" id="bar2"></div>
                  <div class="bars" id="bar3"></div>
                </label>
              </div>
          </button>
          <div class="accordion-content px-5 pb-5 pt-0" data-accordion-content="grid">
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-44 text-white-castom">Кол-во колонок:</span>
              <input id="gridColumns" type="number" min="1" max="6" value="3" class="w-16 rounded-lg border px-2 py-1 bg-[rgb(var(--stickyHeader-rgb)/0.7)] text-white-castom font-medium outline-none transition" aria-describedby="tip-gridColumns" />
              <span class="tooltip-settings" id="tip-gridColumns">
                <span style="font-size: 1rem;"><p>Планировка "офиса" камер 🏢</p></span>
                <p>Выберите <strong>количество колонок</strong> от 1 до 6 <em>(как расставляете рабочие места в open space)</em>.</p>
                <p>1 колонка - для важного проекта, 6 - для тотального наблюдения. Вы же начальник этого пластикопроизводства!</p>
                <p>📊 <i>Совет: 3-4 колонки - золотая середина между обзором и читаемостью</i></p></span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <label class="container-chekbox">
                <input id="enableDividersCheckbox" type="checkbox" />
                <svg viewBox="0 0 64 64" height="1em" width="1em">
                  <path d="M 0 16 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 16 L 32 48 L 64 16 V 8 A 8 8 90 0 0 56 0 H 8 A 8 8 90 0 0 0 8 V 56 A 8 8 90 0 0 8 64 H 56 A 8 8 90 0 0 64 56 V 16" pathLength="575.0541381835938" class="path-chekbox"></path>
                </svg>
              </label>
              <span class="text-white-castom">Показывать разделители</span>
              <span class="tooltip-settings">
                <span style="font-size: 1rem;"><p>Видео-регламентатор 📐</p></span>
                <p>Галочка добавляет <strong>горизонтальный разделители</strong> между строками <em>(как разлиновываете страницу важного отчёта)</em>.</p>
                <p>Превращает хаос видеоокон в упорядоченную таблицу - чтобы каждый поток знал своё место!</p>
                <p>🧾 <i>Совет: включите, если ваши камеры ведут себя как сотрудники без должностных инструкций</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-44 text-white-castom">Цвет разл.:</span>
              <input id="dividerColor" type="color" value="#ba88e2" class="color-input" aria-describedby="tip-dividerColor" />
              <span class="tooltip-settings" id="tip-dividerColor">
                <span style="font-size: 1rem;"><p>Цвет корпоративных границ 🎨</p></span>
                <p>Выберите <strong>оттенок для разделительных линий</strong> <em>(как утверждаете цвет линий в фирменных бланках)</em>.</p>
                <p>Серый для минимализма, красный для срочности, синий - чтобы линии выглядели "по-деловому".</p>
                <p>📌 <i>Совет: используйте приглушенные оттенки - они направляют взгляд, но не кричат как опоздавший на совещание</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-44 text-white-castom">Толщина:</span>
              <input id="dividerThickness" type="range" min="1" max="5" step="0.5" value="2" class="flex-1 custom-range" aria-describedby="tip-dividerThickness" />
              <span class="tooltip-settings" id="tip-dividerThickness">
                <span style="font-size: 1rem;"><p>Толщина корпоративных границ 📏</p></span>
                <p>Настройте <strong>весомость разделительных линий</strong> <em>(от "тонких как намёк" до "толстых как директивное указание")</em>.</p>
                <p>Тонкие - для деликатного зонирования, жирные - когда нужно провести черту как в бухгалтерском отчёте.</p>
                <p>⚖️ <i>Совет: 20% - идеальный баланс между заметностью и ненавязчивостью</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative">
              <span class="w-44 text-white-castom">Ширина (%):</span>
              <input id="dividerWidth" type="range" min="10" max="100" step="2" value="96" class="flex-1 custom-range" aria-describedby="tip-dividerWidth" />
              <span id="dividerWidthValue" class="w-12 text-right text-white-castom">96%</span>
              <span class="tooltip-settings" id="tip-dividerWidth">
                <span style="font-size: 1rem;"><p>Ширина разделителей 📊</p></span>
                <p>Определите <strong>ширину</strong> для линии-разделителя <em>(как выделяете бюджет на проекты: скромно, щедро или по остаточному принципу)</em>.</p>
                <p>50% - деликатное присутствие, 100% - доминирующая позиция, 80% - золотая середина между скромностью и амбициями.</p>
                <p>💸 <i>Совет: 100-90% - оптимальные "инвестиции" в разделители, чтобы не схлопнуть пространство</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative mb-2">
              <span class="w-44 text-white-castom">Выравнивание:</span>
              <select id="dividerAlign" class="flex-1 rounded-lg border px-2 py-1 bg-[rgb(var(--stickyHeader-rgb)/0.7)] text-white-castom transition" aria-describedby="tip-dividerAlign">
                <option value="left">Слева</option>
                <option value="center" selected>По центру</option>
                <option value="right">Справа</option>
              </select>
              <span class="tooltip-settings" id="tip-dividerAlign">
                <span style="font-size: 1rem;"><p>Дипломатия разделителей</p></span>
                <p>Выберите <strong>позицию линий</strong> в колонках: <em>слева</em> (Западный фланг), <em>справа</em> (Восточный фланг) или <em>центр</em> (Авангард).</p>
                <p>Как расставляете мебель в переговорке - каждая позиция создаёт разное впечатление о пространстве.</p>
                <p>⚔️ <i>Совет: центральное положение - "швейцарский нейтралитет" между контентом</i></p>
              </span>
            </div>
            <div class="flex items-center gap-3 relative">
              <span class="w-44 text-white-castom">Размер имени карт:</span>
              <input id="namedDriv" type="range" min="0.4" max="1.5" step="0.05" value="0.9" class="flex-1 custom-range" aria-describedby="tip-namedDriv" />
              <span id="namedDrivValue" class="w-12 text-right text-white-castom">0.9rem</span>
              <span class="tooltip-settings" id="tip-namedDriv">
                <span style="font-size: 1rem;"><p>Текстовое сопровождение камер 🔊</p></span>
                <p>Настройте <strong>размер текста</strong> в названиях <em>(от "шёпотом на совещании" до "кричит как начальник в пятницу")</em>.</p>
                <p>Маленький - для минималистов, крупный - когда нужно чтобы названия видели даже с последнего ряда переговорки.</p>
                <p>👓 <i>Совет: 0,8 - идеальный "громко-шепот", читаемый с любого офисного кресла</i></p>
              </span>
            </div>
          </div>
        </div>


        <!-- CAMERAS -->
        <div id="mainSectionWrap" class="panel-item card-3d accordion">
          <section class="rounded-xl overflow-hidden flex flex-col h-full">
            <header class="flex items-center justify-between" aria-describedby="tip-cam-settings">
              <button id="openSettingsBtnModal" class="openSettingsBtnModal" aria-label="Настройки">
                <i data-lucide="settings" class="icon-gear w-5 h-5"></i>
                <i data-lucide="x" class="icon-close w-5 h-5 hidden"></i>
              </button>
              <button type="button" id="buttonAccordionCamers" class="w-full flex items-center justify-between px-5 py-4 font-semibold text-lg tracking-tight accordion-toggle" aria-expanded="true" tabindex="0">
                <span class="flex items-center gap-3">
                  <i data-lucide="video" class="w-7 h-7 text-white-castom"></i>
                  <span class="text-white-castom-80" >Сетка камер</span>
                </span>
                  <div class="custom-checkbox-container">
                    <input type="checkbox" id="accordion-checkbox-cameras" class="accordion-checkbox">
                    <label for="accordion-checkbox-cameras" class="toggle">
                      <div class="bars" id="bar1"></div>
                      <div class="bars" id="bar2"></div>
                      <div class="bars" id="bar3"></div>
                    </label>
                  </div>
              </button>
            </header>
                            

            <div id="tableWrapper" class="accordion-content" data-accordion-content="cameras">
                <div class="scrollable-table">
                  <div id="dropIndicator" aria-hidden="true" class="dropIndicator"></div>
                  <table class="w-full text-sm">
                    <colgroup><col style="width:5%"><col style="width:22%"><col style="width:34%"><col style="width:32%"><col style="width:7%"></colgroup>
                    <thead>
                      <tr class="sticky-header">
                        <th class="px-3 py-2 rounded-tl-2xl"></th>
                        <th class="px-3 py-2 font-medium text-right">IP</th>
                        <th class="px-3 py-2 text-left font-medium">Stream</th>
                        <th class="px-3 py-2 text-left font-medium border-l border-[rgb(var(--white)/0.1)]">Название</th>
                        <th class="px-3 py-2 rounded-tr-2xl"></th>
                      </tr>
                    </thead>
                    <tbody id="camerasTableBody" class="camerasTableBody">
                      <!-- Здесь выводится список камер -->
                    </tbody>
                  </table>
                </div>
              <div id="mainButtons" class="flex flex-row gap-4 px-6 py-3">
                <button id="addCameraBtn" class="w-1/2 glass-btn btn-3d text-white-castom font-semibold py-3 rounded-xl hover:text-white-castom transition-all duration-200 flex items-center justify-center gap-2 outline-none"><i data-lucide="plus" class="w-5 h-5"></i><span>Добавить камеру</span></button>
                <button id="addDammyCameraBtn" class="w-1/2 glass-btn btn-3d text-white-castom font-semibold py-3 rounded-xl hover:text-white-castom transition-all duration-200 flex items-center justify-center gap-2 outline-none"><i data-lucide="plus" class="w-5 h-5"></i><span>Добавить пустой слот</span></button>
              </div>
            </div>
          </div>
        </section>
      </div>  
      

      <!-- Кнопки -->
      <div class="flex flex-row gap-3">
        <button id="applyChangesBtn"
          class="w-1/2 glass-btn btn-3d text-white-castom font-semibold py-3 rounded-xl hover:bg-gradient-to-br hover:from-green-400 hover:to-emerald-500/60 hover:text-white-castom transition-all duration-200 flex items-center justify-center gap-2 outline-none"
          aria-label="Применить изменения"
        >
          <i data-lucide="check" class="w-5 h-5"></i> Применить
        </button>
        <button id="resetSettingsBtn"
          class="w-1/2 glass-btn btn-3d text-white-castom font-semibold py-3 rounded-xl hover:bg-gradient-to-br hover:from-red-500 hover:to-fuchsia-500/60 hover:text-white-castom transition-all duration-200 flex items-center justify-center gap-2 outline-none"
          aria-label="Сбросить настройки"
        >
          <i data-lucide="trash-2" class="w-5 h-5"></i> Сбросить
        </button>
      </div>

      <!-- КНОПКА Импорт/Экспорт -->
      <div id="importExportBtnBlock">
        <button
          id="showImportExportBtn"
          class="w-full glass-btn btn-3d text-white-castom font-semibold py-3 rounded-xl hover:text-white-castom transition-all duration-200 flex items-center justify-center gap-2 outline-none"
          aria-label="Открыть блок импорта и экспорта"
        >
          <i data-lucide="import" class="w-5 h-5"></i>
          Импорт/Экспорт настроек
        </button>
      </div>

      <!-- Импорт/Экспорт (модальное окно) -->
      <div id="importExportBlock" class="fixed md:static bottom-0 left-0 right-0 mx-auto w-full max-w-md md:max-w-none z-[999] pointer-events-none opacity-0 translate-y-10 scale-95 transition-all duration-500" style="display:none;">
        <div class="dropzone dropzone-3d bg-white/10 shadow-xl p-8 relative overflow-hidden" tabindex="0" aria-label="Импорт настроек (drag and drop)" autocomplete="off">
          <!-- Добавляем анимированный фоновый градиент -->
          <div class="absolute inset-0 bg-gradient-to-br from-[rgb(var(--tetrad1-light-rgb)/0.1)] via-[rgb(var(--tetrad-color1-rgb)/0.1)] to-[rgb(--tetrad1-dark-rgb)/0.1)] animate-gradient-slow pointer-events-none"></div>
          <!-- Основной контент -->
          <div class="relative z-10">
            <i data-lucide="upload-cloud" class="dz-icon w-12 h-12 mx-auto mb-4 text-white-castom-80 animate-bounce-slow"></i>
            <span class="dz-label block text-center text-lg font-medium mb-2 text-white-castom-80">Перетащите файл настроек сюда</span>
            <span class="dz-or block text-center text-sm text-white-castom-80 mb-6">или</span>
            <!-- Группа кнопок в ряд -->
            <div class="flex flex-col sm:flex-row gap-3 justify-center items-stretch">
              <!-- Кнопка выбора файла -->
              <label class="glass-btn btn-3d flex-1 text-white-castom font-semibold px-6 py-3 rounded-xl 
                          transition-all duration-200 flex items-center justify-center gap-2 cursor-pointer">
                <i data-lucide="file-up" class="w-5 h-5"></i>
                <span>Выбрать файл</span>
                <input id="importFile" type="file" accept=".json,.txt" class="hidden" aria-label="Импорт файла настроек">
              </label>
              <!-- Кнопка экспорта -->
              <button id="exportBtn" type="button" 
                      class="glass-btn btn-3d flex-1 text-white-castom font-semibold px-6 py-3 rounded-xl 
                             transition-all duration-200 flex items-center justify-center gap-2">
                <i data-lucide="download" class="w-5 h-5"></i>
                <span>Экспорт</span>
              </button>
              <!-- Кнопка закрытия -->
              <button id="closeImportExportBtn" type="button"
                      class="glass-btn btn-3d flex-1 text-white-castom font-semibold px-6 py-3 rounded-xl 
                             transition-all duration-200 flex items-center justify-center gap-2">
                <i data-lucide="x" class="w-5 h-5"></i>
                <span>Закрыть</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </aside>
  <!-- Модальное окно сброса настроек -->
  <div id="resetConfirmModal" class="fixed inset-0 z-50 bg-black/60 flex items-center justify-center hidden">
    <div class="bg-white rounded-xl shadow-2xl px-8 py-7 max-w-sm w-full text-center border-2 border-yellow-500 animate-pulse">
      <h3 class="text-lg font-semibold mb-2 text-red-600">Сброс настроек</h3>
      <p class="mb-5 text-gray-600 text-sm">Вы собираетесь сбросить настройки на стандартные. При этом будут удалены все IP/URL камер.</p>
      <div class="flex justify-center gap-3">
        <button id="confirmResetBtn"
          class="bg-red-500 hover:bg-red-600 transition text-white-castom px-5 py-2 rounded font-semibold">Сбросить</button>
        <button id="cancelResetBtn"
          class="bg-gray-300 hover:bg-gray-400 transition text-gray-800 px-5 py-2 rounded font-semibold">Отменить</button>
      </div>
    </div>
  </div>

  <!-- Оверлей -->
  <div id="overlay"></div>
  <!-- Модальное окно "Print_Fab" -->
  <div id="helpModal" class="fixed inset-0 z-50 invisible opacity-0 transition-all duration-300 flex items-center justify-center backdrop-blur-sm" aria-modal="true" aria-labelledby="modalTitle" aria-hidden="true">
    <div id="modalDialog" class="relative modal-glass rounded-2xl w-full px-0 py-0 md:p-0 shadow-2xl border border-[rgb(var(--avg-light-rgb)/0.9)] flex flex-col modal-fade-in max-h-[92vh] max-w-[62vw]">
      <!-- SVG лучи/блеск -->
      <svg class="absolute top-0 left-1/2 -translate-x-1/2 ray" width="320" height="320" fill="none" viewBox="0 0 320 320" style="z-index:0;">
        <defs>
          <radialGradient id="ray1" cx="0.5" cy="0.4" r="0.7">
            <stop stop-color="#c4b5fd" stop-opacity="0.25"></stop>
            <stop offset="1" stop-color="#f472b6" stop-opacity="0"></stop>
          </radialGradient>
        </defs>
        <circle cx="160" cy="120" r="120" fill="url(#ray1)"></circle>
      </svg>
      <!-- Контент с прокруткой -->
      <div class="relative z-10 flex flex-col h-full min-h-[420px]">
        <div class="flex-1 overflow-y-auto px-6 py-8 md:p-10 scrollbar-thin" tabindex="0">
          <div class="flex items-center gap-3 mb-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="badge-help" class="lucide lucide-badge-help lucide-camera w-[32px] h-[32px] text-[rgb(var(--tetrad2-light-rgb))]"><path d="M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z"></path><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" x2="12.01" y1="17" y2="17"></line></svg>
            <h2 id="modalTitle" class="text-2xl md:text-3xl font-semibold tracking-tight text-[rgb(var(--tetrad2-light-rgb))]">Помощь и инструкция</h2>
          </div>
          <p class="text-[rgb(var(--textW1-rgb))] text-base md:text-lg mb-4">
            Это интерфейс мониторинга IP-камер для 3D-принтеров с расширенной системой кастомизации, уведомлений и гибкой сеткой.
          </p>
          <div class="space-y-6 text-base">
            <div class="flex items-start gap-4 animate-fade-in">
              <i data-lucide="settings" class="w-6 h-6 flex-shrink-0 mt-0.5 text-[rgb(var(--tetrad2-light-rgb))]"></i>
              <div class="max-w-5xl">
                <h2 class="font-semibold text-2xl text-[rgb(var(--textW1-rgb))] mb-4">Гибкие настройки интерфейса</h2>
                <ul class="mt-1 text-[rgb(var(--textW1-rgb)/0.8)] text-[15px] ml-5 list-disc space-y-3">
                  <li>
                    <span class="font-semibold">Волшебное меню трансформации</span> ищите в выпадающем списке <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">рядом с кнопкой помощи</span><div class="mt-1 ml-2">Там собраны все инструменты для перекрашивания реальности</div>
                  </li>
                  <li>
                    <span class="font-semibold">Описания с изюминкой</span> - наши технари постарались, <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">чтобы документация не усыпляла</span><div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Читайте и смейтесь, но настройки всё равно придёте делать!</div>
                  </li>
                  <li>
                    <span class="font-semibold">Цветовая схема</span> - ваш билет в <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">визуальный рай/ад</span><div class="mt-1 ml-2">Выбирайте оттенки, которые не будут резать глаза в 3 часа ночи</div>
                  </li>
                  <li>
                    <span class="font-semibold">Загрузка</span> - управляйте <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">приветственным экраном</span><div class="mt-1 ml-2">Можно выключить, сделать прозрачным или... продолжать медитировать пока определяется статус принтеров</div><div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Наши инженеры называют это "экран философской паузы"</div>
                  </li>
                  <li>
                    <span class="font-semibold">Шапка интерфейса</span> - настраивается под <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">ваш вкус</span><div class="mt-1 ml-2">Уберите лишнее или добавьте своё - как в любимом ресторане быстрого питания</div>
                  </li>
                  <li>
                    <span class="font-semibold">Сетка камер</span> - разлинуйте рабочее пространство <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">в шахматную доску</span><div class="mt-1 ml-2">Колонки, разделители, подписи - всё под вашим контролем</div><div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Совет: 6 колонок на ноутбуке превратят экран в муравейник!</div>
                  </li>
                  <li><span class="font-semibold text-red-300">ВНИМАНИЕ!</span> Чрезмерное украшательство может вызвать зависть коллег</li>
                </ul>
                <div class="mt-6 p-3 text-[rgb(var(--textW1-rgb))] bg-blue-900/30 rounded-lg border border-dashed border-blue-400">
                  <span class="font-semibold">Профессиональный совет:</span> Если интерфейс стал похож на новогоднюю ёлку - вы переборщили с настройками!
                </div>
              </div>
            </div>
            <div class="flex items-start gap-4 animate-fade-in">
              <i data-lucide="video" class="w-6 h-6 flex-shrink-0 mt-0.5 text-[rgb(var(--tetrad2-light-rgb))]"></i>
              <div class="max-w-5xl">
                <h2 class="font-semibold text-2xl text-[rgb(var(--textW1-rgb))] mb-4">
                  Управление камерами: инструкция для тех, кто не хочет играть в "угадай порт"
                </h2>
                <ul class="mt-1 text-[rgb(var(--textW1-rgb)/0.8)] text-[15px] ml-5 list-disc space-y-3">
                  <li>
                    <span class="font-semibold">IP-адрес принтера</span> - вводим без <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">http://</span>
                    <div class="mt-1 ml-2">
                      Пример: <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">192.168.0.2</span><br>
                      Для нестандартных портов, при использовании нескольких Web интерфейсов (Fluid/Mainsail): <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">192.168.0.2:81</span>
                    </div>
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Если ваш принтер использует порт 80, он автоматически считает себя VIP-устройством</div>
                  </li>
                  <li>
                    <span class="font-semibold">Видеопоток</span> - указываем путь к трансляции:
                    <div class="mt-1 ml-2">
                      Пример: <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">:8080/?action=stream</span><br>
                      Система <span class="magick-text">автомагически</span> соберет URL: <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">192.168.0.2:8080/?action=stream</span> для видео потока
                    </div>
                  </li>
                  <li>
                    <span class="font-semibold">Кнопка-волшебник</span> 
                    <button class="stream-toggle inline-flex items-center p-1 rounded-lg bg-[rgb(var(--tetrad2-dark-rgb)/0.8)] text-[rgb(var(--white))] transition mx-1">
                      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="shuffle" class="lucide lucide-shuffle w-4 h-4"><path d="m18 14 4 4-4 4"></path><path d="m18 2 4 4-4 4"></path><path d="M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22"></path><path d="M2 6h1.972a4 4 0 0 1 3.6 2.2"></path><path d="M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45"></path></svg>
                    </button>
                    автоматически подбирает настройки потока. Повторное нажатие - альтернативный вариант.
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Работает лучше, чем гадалка на картах Таро</div>
                  </li>
                  <li>
                    <span class="font-semibold">Режим кинотеатра</span> - нажмите <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">⚙️</span> для полноэкранного просмотра. 
                    Выход - появившийся крестик <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">✕</span> в верхнем углу экрана <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Не тот о котором вы подумали</div>
                  </li>
                  <li>
                    <span class="font-semibold">Расстановка камер</span> - меняйте порядок перетаскиванием (Drag&Drop), 
                    добавляйте новые или создавайте пустые слоты. 
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Как Tetris, только с пользой для производства</div>
                  </li>
                  <li>
                    <span class="font-semibold text-red-300">ВНИМАНИЕ!</span> Не забудьте сохранить настройки кнопкой 
                    <span class="font-mono bg-red-900 px-2 py-0.5 rounded">Сохранить</span>, иначе система "забудет" изменения после перезагрузки страницы.
                  </li>
                </ul>
                <div class="mt-6 p-3 text-[rgb(var(--textW1-rgb))] bg-blue-900/30 rounded-lg border border-dashed border-blue-400">
                  <span class="font-semibold">Профессиональный совет:</span> 
                  Если ваш принтер внезапно начал транслировать кота, спящего на нагретой платформе - 
                  вы всё сделали правильно! 😺
                </div>
              </div>
            </div>
            <div class="flex items-start gap-4 animate-fade-in">
              <i data-lucide="layout-grid" class="w-6 h-6 flex-shrink-0 mt-0.5 text-[rgb(var(--tetrad2-light-rgb))]"></i>
              <div class="max-w-5xl">
                <h2 class="font-semibold text-2xl text-[rgb(var(--textW1-rgb))] mb-4">Интерфейс: где магия встречает логику</h2>
                <ul class="mt-1 text-[rgb(var(--textW1-rgb)/0.8)] text-[15px] ml-5 list-disc space-y-3">
                  <li>
                    <span class="font-semibold">Попкорн-уведомления</span> - чем больше принтеров, тем интенсивнее шоу. Не переживайте, автосворачиване 
                    <span class="font-mono bg-green-700 px-1 rounded"> Включено</span> по умолчанию
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Если много принтеров готовьтесь к <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">фестивалю оповещений</span><br>Каждый принтер считает долгом сообщить о сврем прибытии или отсутствии</div>
                  </li>
                  <li>
                    <span class="font-semibold">Карточный домик</span> - тащите камеры и слоты куда душе угодно!
                    <div class="mt-1 ml-2">Но чтобы изменения не испарились, жмите 
                      <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">волшебную кнопку с дискетой</span>
                      (она же "<span class="font-mono bg-green-700 px-1 rounded">Сохранить</span>", находится рядом с кнопкой помощи)</div>
                  </li>
                  <li>
                    <span class="font-semibold">Воскрешение принтеров</span> Жмите 
                    <span class="font-mono bg-green-700 px-1 rounded">Обновить</span> Система заново познакомится с вашими устройствами если до этого они были <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">ofline</span>
                  </li>
                  <li>
                    <span class="font-semibold">Охота за разделителями</span> - кликайте по лишним линиям,
                    <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--white))] rounded">они исчезнут!</span>
                    <div class="mt-1 ml-2">Не забудьте потом нажать 
                      <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">ту самую дискету</span> иначе ваши труды канут в небытие
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Дизайнеры плачут, когда вы расставляете разделители хаотично</div>
                  </li>
                  <li>
                    <span class="font-semibold">Светофор статусов</span>:
                    <div class="mt-1 ml-2">
                      <span class="font-semibold text-red-400">Красный</span> - принтер в отпуске<br>
                      <span class="font-semibold text-yellow-400">Желтый</span> - камера стесняется (нет видеопотока)<br>
                      <span class="font-semibold text-green-400">Зеленый</span> - полный фарш! Можно и управлять, и смотреть
                    </div>
                  </li>
                  <li>
                    <span class="font-semibold">Карточка-трансформер</span> - жмите на иконки внутри карточки принтера для магии:
                    <div class="mt-1 ml-2">
                      <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">Полный экран</span> - видео увеличится (подведите курсор к краю для легкого уменьшения)<br>
                      <span class="italic text-[rgb(var(--textW1-rgb)/0.8)] px-1 rounded shadow-md">Веб-интерфейс</span> - видео остановится для быстрой загрузки вашего web интерфейса. 
                      После закрытия - <span class="font-mono bg-gray-700 px-1 text-[rgb(var(--textW1-rgb)/0.8)] rounded">автообновление видео потоков</span> как по волшебству
                    </div>
                    <div class="text-sm italic mt-1 text-[rgb(var(--tetrad-color1-rgb))]">Плюсы быстрая загрузка, минусы снова попкорн шоу из уведомлений</div>
                  </li>
                  <li><span class="font-semibold text-red-300">ВНИМАНИЕ!</span> Чрезмерное кликание по дискете может вызвать ностальгию по 90-м</li>
                </ul>
                <div class="mt-6 p-3 text-[rgb(var(--textW1-rgb))] bg-blue-900/30 rounded-lg border border-dashed border-blue-400">
                  <span class="font-semibold"></span> Если Ваш интерфейс стал похож на панель управления космическим кораблём - вы на верном пути!
                </div>
              </div>
            </div>
            <div class="flex items-start gap-4 animate-fade-in">
              <i data-lucide="smartphone" class="w-6 h-6 flex-shrink-0 mt-0.5 text-[rgb(var(--tetrad2-light-rgb))]"></i>
              <div>
                <span class="font-semibold text-[rgb(var(--textW1-rgb))]">Адаптивность</span>
                <ul class="mt-1 text-[rgb(var(--textW1-rgb)/0.8)] text-[15px] ml-5 list-disc space-y-0.5">
                  <li>Интерфейс адаптирован под любые экраны.</li>
                  <li>Панель инструментов автоматически появляется при скрытом заголовке.</li>
                </ul>
              </div>
            </div>
          </div>
          <div class="my-6 border-t border-[rgb(var(--scrollableTableB-rgb))]"></div>
          <div class="text-sm flex items-center gap-2 animate-fade-in text-[rgb(var(--textW1-rgb)/0.8)]">
              <p class="text-lg leading-relaxed flex items-start gap-3">
              <i data-lucide="info" class="stroke-[1.5] w-6 h-6 shrink-0" style="color: rgb(var(--tetrad2-light-rgb));"></i>

              <span>
                Вы уже ознакомлены и&nbsp;приняли правила использования, которые отображались при&nbsp;первом запуске.
                Для&nbsp;повторного ознакомления с&nbsp;правилами воспользуйтесь
                <button id="consetModalBtn"
                  type="button"
                  class="group relative inline-block font-medium transition duration-300 ease-in-out hover:scale-[1.02] focus:outline-none"
                  style="
                    background-image:linear-gradient(90deg,rgb(170,218,242),rgb(2,41,84),rgb(170,218,242));
                    background-size:400% 400%;
                    -webkit-background-clip:text;
                    background-clip:text;
                    color:transparent;
                    animation:gradient-shift 7s ease-in-out infinite;">
                  предоставленной ссылкой
                  <!-- Gradient underline (visible only on hover) -->
                  <span
                    class="absolute left-0 -bottom-0.5 h-0.5 w-full opacity-0 transition-opacity duration-300 group-hover:opacity-100"
                    style="
                      background-image:linear-gradient(90deg,rgb(170,218,242),rgb(2,41,84),rgb(170,218,242));
                      background-size:400% 400%;
                      animation:gradient-shift 7s ease-in-out infinite;"></span>
                </button>
              </span>
            </p>
          </div>
          <div class="my-6 border-t border-[rgb(var(--scrollableTableB-rgb))]"></div>

        </div>
        <div class="flex justify-end p-6 pt-3 pb-5 border-t via-transparent to-transparent border-[rgb(var(--avg-light-rgb))]">
          <div class="absolute left-8 flex items-start gap-2 animate-fade-in">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="copyright" class="lucide lucide-copyright w-5 h-5 mt-0.5 text-[rgb(var(--scrollableTableB-rgb))]"><circle cx="12" cy="12" r="10"></circle><path d="M14.83 14.83a4 4 0 1 1 0-5.66"></path></svg>
            <div class="text-[15px]">
              <span class="block mb-1 text-[rgb(var(--scrollableTableB-rgb))]">by <span class="font-semibold text-[rgb(var(--scrollableTableB-rgb))]">vitaliy.kodochigov 2025</span></span>
            </div>
          </div>
          <!-- Блок соцсетей -->
          <div class="animate-fade-in">
            <div class="right-8 flex flex-row gap-3 items-center justify-start pr-2 mt-2 pb-2">
              <!-- Telegram -->
              <button class="social-btn w-12 h-12 rounded-full flex items-center justify-center group relative" style="background: linear-gradient(135deg, rgb(0, 140, 204), rgb(0, 170, 255), rgb(0, 207, 255));" aria-label="Telegram" tabindex="0" onclick="window.open('https://t.me/Vitaliy_Kodochigov','_blank')">
                <svg data-lucide="send" class="w-6 h-6 text-white-castom" width="24" height="24"></svg>
                <span class="tooltip">Telegram</span>
              </button>
              <!-- VK -->
              <button class="social-btn w-12 h-12 rounded-full flex items-center justify-center group relative" style="background: linear-gradient(135deg, rgb(62, 121, 241), rgb(115, 67, 242), rgb(148, 92, 245));" aria-label="VK" tabindex="0" onclick="window.open('https://vk.com/vitaliy.kodochigov','_blank')">
                <svg viewBox="0 0 24 24" class="w-6 h-6 text-white-castom" fill="currentColor">
                  <path d="M20.588 6.197c.139-.463 0-.803-.664-.803h-2.2c-.557 0-.814.295-.955.623 0 0-1.116 2.7-2.694 4.455-.511.511-.744.673-1.021.673-.138 0-.347-.162-.347-.625V6.197c0-.556-.154-.803-.606-.803H7.126c-.347 0-.556.259-.556.504 0 .527.786.649.868 2.133v3.224c0 .708-.127.84-.406.84-.744 0-2.56-2.72-3.64-5.823-.213-.612-.428-.867-.999-.867H1.243c-.636 0-.764.295-.764.623 0 .583.744 3.472 3.472 7.294 1.818 2.586 4.364 3.985 6.697 3.985 1.394 0 1.567-.312 1.567-.867V16.18c0-.624.131-.741.567-.741.322 0 .874.163 2.162 1.414 1.475 1.475 2.185 2.151 3.235 2.151.636 0 .762-.312.762-.624v-2.073c0-.58-.104-.823-.66-.823-.342 0-.93.162-2.308 1.414-.601.51-.871.673-1.142.673-.138 0-.347-.161-.347-.625v-3.18c0-.556.154-.803.606-.803h2.2c.557 0 .814.295.955.623z"/>
                </svg>
                <span class="tooltip">VK</span>
              </button>
              <!-- WhatsApp -->
              <button class="social-btn w-12 h-12 rounded-full flex items-center justify-center group relative" style="background: linear-gradient(135deg, rgb(58, 187, 93), rgb(76, 175, 80), rgb(46, 196, 182));" aria-label="WhatsApp" tabindex="0" onclick="window.open('https://wa.me/79617763377','_blank')">
                <svg data-lucide="phone" class="w-6 h-6 text-white-castom" width="24" height="24"></svg>
                <span class="tooltip">WhatsApp</span>
              </button>
              <!-- Email -->
              <button class="social-btn w-12 h-12 rounded-full flex items-center justify-center group relative" style="background: linear-gradient(135deg, rgb(255, 92, 92), rgb(112, 66, 255));" aria-label="Email" tabindex="0" onclick="window.open('mailto:vitaliy.kodochigov@mail.ru','_blank')">
                <svg data-lucide="mail" class="w-6 h-6 text-white-castom" width="24" height="24"></svg>
                <span class="tooltip">Email</span>
              </button>
              <!-- Web-site -->
              <button class="social-btn w-12 h-12 rounded-full flex items-center justify-center group relative" style="background: linear-gradient(135deg, rgb(255, 87, 34), rgb(193, 76, 45), rgb(121, 60, 37), rgb(220, 220, 220));" aria-label="Web-site" tabindex="0" onclick="window.open('https://print-fab.ru','_blank')">
                <svg data-lucide="globe" class="w-6 h-6 text-white-castom" width="24" height="24"></svg>
                <span class="tooltip">Web-site</span>
              </button>
            </div>
          </div>
          <button id="closeHelpModal"></button>
        </div>
      </div>
    </div>
  </div>
  <!-- CONSENT MODAL -->
  <div id="consentModal" class="fixed inset-0 z-50 flex flex-col overflow-y-auto bg-black bg-[radial-gradient(ellipse_at_top_left,rgba(13,17,23,0.85),rgb(var(--surface))_60%)] text-slate-100 selection:bg-indigo-500/30 hidden">
    <!-- wrapper -->
    <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-10 space-y-20">
      <!-- welcome -->
      <section id="Start" class="relative rounded-3xl overflow-hidden p-10 bg-gradient-to-br from-indigo-800/50 to-fuchsia-800/30 shadow-xl ring-1 ring-white/10 reveal mt-[12vh]">

        <div class="relative space-y-5">
          <div class="flex items-center gap-3">
            <i data-lucide="star" class="w-8 h-8 text-fuchsia-400"></i>
            <h2 class="text-3xl md:text-4xl font-semibold tracking-tight text-white">
              Вы увидите это сообщение всего один раз
            </h2>
          </div>
          <p class="text-lg/relaxed max-w-3xl">
            Пожалуйста, дочитайте его до конца — мы постарались сделать его интересным и полезным. Это как калибровка стола перед важной печатью: немного времени сейчас сэкономит много нервов потом!
          </p>
          <div class="flex items-start gap-3 bg-slate-800/60 rounded-lg p-4">
            <i data-lucide="lightbulb" class="w-6 h-6 text-indigo-400 flex-shrink-0 mt-0.5"></i>
            <p>Мы вложили в этот текст столько сил, сколько обычно уходит на 28-часовую печать.</p>
          </div>
        </div>
      </section>

      <!-- header -->
      <header class="text-center space-y-6 reveal">
        <h1 class="text-4xl md:text-5xl font-semibold tracking-tight text-white">
          Условия использования приложения
        </h1>
        <div class="mx-auto h-px w-24 bg-gradient-to-r from-indigo-500 via-fuchsia-500 to-indigo-500"></div>
        <p class="text-xl text-indigo-300 max-w-2xl mx-auto">
          Технические аспекты и правовые нормы интеграции системы мониторинга 3D-печати
        </p>
      </header>

      <!-- legal -->
      <section class="rounded-3xl bg-[rgb(var(--surface-alt))] ring-1 ring-white/5 shadow-2xl p-10 space-y-12 reveal">
        <div class="flex items-start gap-6">
          <i data-lucide="scale" class="w-12 h-12 text-indigo-400"></i>
          <div>
            <h2 class="text-3xl font-semibold tracking-tight text-white">Юридические условия использования</h2>
            <p class="text-indigo-300 mt-1">Официальное правовое регулирование</p>
          </div>
        </div>

        <div class="space-y-10">

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="gift" class="w-6 h-6 text-fuchsia-400 mt-1"></i>
            <div>
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Бесплатное распространение</h3>
              <p class="text-slate-300/90">
                Настоящее приложение распространяется на безвозмездной основе. Разработчики не преследуют коммерческих целей и не получают финансовой выгоды от его использования.
              </p>
              <div class="mt-4 bg-indigo-500/10 border border-indigo-500/30 rounded-lg p-4 text-sm">
                <span class="font-medium">Важно:</span> Мы оставляем за собой право на дальнейшее развитие проекта, но гарантируем, что базовый функционал всегда останется бесплатным.
              </div>
            </div>
          </article>

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="copyright" class="w-6 h-6 text-indigo-400 mt-1"></i>
            <div>
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Авторские права и атрибуция</h3>
              <p class="text-slate-300/90">
                Любое использование, распространение или модификация программного обеспечения должно сопровождаться сохранением информации о разработчике в неизменном виде.
              </p>
              <div class="mt-4 bg-slate-800 border border-slate-600 rounded-lg p-4 text-sm">
                <span class="font-medium text-indigo-300">Обязательное требование:</span> Запрещено удаление, изменение или сокрытие ссылок на социальные сети разработчика, контактной информации и упоминаний об авторских правах.
              </div>
            </div>
          </article>

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="briefcase" class="w-6 h-6 text-indigo-400 mt-1"></i>
            <div>
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Условия использования</h3>
              <ul class="list-disc pl-6 space-y-2 text-slate-300/90">
                <li>Приложение готово к немедленной интеграции в процессы мониторинга 3D-печати</li>
                <li>Разрешено личное и коммерческое использование без лицензионных отчислений</li>
                <li>Запрещено применение, нарушающее законодательство РФ или международные нормы</li>
              </ul>
            </div>
          </article>

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="shield" class="w-6 h-6 text-indigo-400 mt-1"></i>
            <div class="w-full">
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Безопасность и конфиденциальность</h3>
              <div class="grid md:grid-cols-2 gap-4">
                <div class="bg-slate-800 rounded-lg p-4">
                  <div class="flex items-center gap-2 mb-1.5">
                    <i data-lucide="check-circle" class="w-5 h-5 text-fuchsia-400"></i>
                    <span class="font-medium">Локальная обработка</span>
                  </div>
                  <p class="text-slate-300/90 text-sm">
                    Весь программный код выполняется исключительно на вашем оборудовании без внешних ресурсов.
                  </p>
                </div>
                <div class="bg-slate-800 rounded-lg p-4">
                  <div class="flex items-center gap-2 mb-1.5">
                    <i data-lucide="database" class="w-5 h-5 text-indigo-400"></i>
                    <span class="font-medium">Хранение данных</span>
                  </div>
                  <p class="text-slate-300/90 text-sm">
                    Пользовательские данные сохраняются только в памяти браузера. Мы не собираем и не передаём их третьим лицам.
                  </p>
                </div>
              </div>
            </div>
          </article>

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="alert-triangle" class="w-6 h-6 text-orange-400 mt-1"></i>
            <div>
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Правовые последствия</h3>
              <p class="text-slate-300/90 mb-3">Несоблюдение указанных условий влечёт за собой:</p>
              <ul class="list-disc pl-6 space-y-1.5 text-fuchsia-400">
                <li>Ответственность по ст. 1300-1308 ГК РФ</li>
                <li>Судебное преследование с компенсацией ущерба</li>
              </ul>
            </div>
          </article>

          <!-- item -->
          <article class="flex items-start gap-4">
            <i data-lucide="handshake" class="w-6 h-6 text-fuchsia-400 mt-1"></i>
            <div>
              <h3 class="text-xl font-semibold tracking-tight text-white mb-2">Сотрудничество</h3>
              <p class="text-slate-300/90">
                Мы приветствуем предложения по улучшению функциональности. При внесении изменений направляйте модифицированные версии для анализа.
              </p>
              <div class="mt-4 bg-indigo-500/10 border border-indigo-500/30 rounded-lg p-4 text-sm">
                <span class="font-medium">Важно:</span> Присланные улучшения могут быть интегрированы в проект с указанием авторства.
              </div>
            </div>
          </article>

        </div>
      </section>

      <!-- fun version -->
      <section class="rounded-3xl bg-gradient-to-br from-slate-800 to-slate-900 ring-1 ring-white/5 shadow-2xl p-10 space-y-12 reveal">
        <div class="flex items-start gap-6">
          <i data-lucide="smile" class="w-12 h-12 text-fuchsia-400"></i>
          <div>
            <h2 class="text-3xl font-semibold tracking-tight text-white">А теперь для тех, кто предпочитает PLA и юмор занудству</h2>
            <p class="text-lg text-indigo-300 mt-1">То же самое, но без юридического клея</p>
          </div>
        </div>

        <div class="space-y-10">

          <!-- funny card -->
          <div class="bg-slate-800 p-6 rounded-xl space-y-4 ring-1 ring-white/5">
            <div class="flex items-start gap-4">
              <i data-lucide="tag" class="w-8 h-8 text-fuchsia-400"></i>
              <div>
                <h3 class="text-xl font-semibold tracking-tight text-white mb-1.5">
                  Про авторство (или почему нельзя просто взять и отрезать)
                </h3>
                <p> Представьте, что вы напечатали идеальную модель. Красиво, гладко, без волн. А кто-то взял, отрезал ваше имя с подставки и выдаёт за своё. Неприятно? Вот и нам тоже.</p>
              </div>
            </div>
            <div class="flex items-start gap-3 bg-orange-500/10 border border-orange-500/30 rounded-lg p-4 text-sm">
              <i data-lucide="x-circle" class="w-5 h-5 text-orange-400"></i>
              <span><span class="font-semibold">Так что давайте жить честно, друзья!</span> Ставим свои имена гордо, хвалим чужие работы (с указанием автора!), а свои – создаем сами. Честность – тоже классный филамент для печати крепких отношений в сообществе! 😉 И тогда никаких "плаги-атак"!</span>
            </div>
          </div>

          <!-- grid perks -->
          <div class="grid md:grid-cols-2 gap-6">
            <div class="bg-slate-800 p-6 rounded-xl space-y-4 ring-1 ring-white/5">
              <div class="flex items-center gap-3">
                <i data-lucide="gift" class="w-8 h-8 text-fuchsia-400"></i>
                <h3 class="text-xl font-semibold tracking-tight text-white">Бесплатно как воздух в экструдере!</h3> 
              </div>
              <p>Никаких скрытых платежей или «премиум» функций.</p>
              <ul class="space-y-2 text-sm">
                <li class="flex gap-2 items-start"><i data-lucide="heart" class="w-5 h-5 text-indigo-400 mt-0.5"></i>Делаем из любви к 3D-печати</li>
                <li class="flex gap-2 items-start"><i data-lucide="wallet" class="w-5 h-5 text-orange-400 mt-0.5"></i>Деньги лучше потратить на филамент или новый хотэнд!</li>
                <li class="flex gap-2 items-start"><i data-lucide="users" class="w-5 h-5 text-indigo-400 mt-0.5"></i>Единственная «плата» — сохранить упоминание о нас.</li>
              </ul>
            </div>

            <div class="bg-slate-800 p-6 rounded-xl space-y-4 ring-1 ring-white/5">
              <div class="flex items-center gap-3">
                <i data-lucide="factory" class="w-8 h-8 text-fuchsia-400"></i>
                <h3 class="text-xl font-semibold tracking-tight text-white">Где можно использовать</h3>
              </div>
              <ul class="space-y-2 text-sm">
                <li class="flex gap-2 items-start"><i data-lucide="home" class="w-5 h-5 text-indigo-400 mt-0.5"></i>Дома — чтобы следить, не сжег ли принтер квартиру</li>
                <li class="flex gap-2 items-start"><i data-lucide="building-2" class="w-5 h-5 text-orange-400 mt-0.5"></i>На производстве — контролировать армию принтеров</li>
                <li class="flex gap-2 items-start"><i data-lucide="coins" class="w-5 h-5 text-orange-400 mt-0.5"></i>В офисе — когда коллеги переселили принтеры в соседний кабинет изи за шума</li>
              </ul>
            </div>
          </div>

          <!-- privacy fun -->
          <div class="bg-slate-800 p-6 rounded-xl space-y-4 ring-1 ring-white/5">
            <div class="flex items-center gap-3">
              <i data-lucide="cloud-off" class="w-8 h-8 text-indigo-400"></i>
              <h3 class="text-xl font-semibold tracking-tight text-white">Про данные и слежку</h3>
            </div>
            <p>Ваши данные не утекают в «облака» — у нас нет сводобных серверов, чтобы хранить видео с ваших устройств</p>
            <div class="flex items-start gap-2 bg-slate-700/60 rounded-lg p-4 text-sm">
              <i data-lucide="brain" class="w-5 h-5 text-fuchsia-400 mt-0.5"></i>
              <span>Вся магия происходит прямо в вашем браузере. Даже без интернета — мониторинг работает.</span>
            </div>
          </div>

          <!-- consequences -->
          <div class="bg-slate-800 p-6 rounded-xl space-y-8 ring-1 ring-white/5">
            <div class="flex items-center gap-3">
              <i data-lucide="alert-octagon" class="w-8 h-8 text-indigo-400"></i>
              <h3 class="text-xl font-semibold tracking-tight text-white">Чем грозит «творческая переработка» без упонимания о нас</h3>
            </div>
            <p>Удаление авторства — это как:</p>
            <div class="grid md:grid-cols-3 gap-4">
              <div class="text-center p-4 bg-red-500/25 rounded-lg space-y-2">
                <i data-lucide="thermometer" class="w-10 h-10 mx-auto text-indigo-400"></i>
                <p class="text-sm leading-snug">Нагревать стол до 160°</p>
              </div>
              <div class="text-center p-4 bg-red-600/30 rounded-lg space-y-2">
                <i data-lucide="zap" class="w-10 h-10 mx-auto text-orange-400"></i>
                <p class="text-sm leading-snug">Обновлять прошивку klipper без понимания, что делаете</p>
              </div>
              <div class="text-center p-4 bg-red-700/35 rounded-lg space-y-2">
                <i data-lucide="flame" class="w-10 h-10 mx-auto text-indigo-400"></i>
                <p class="text-sm leading-snug">Оставлять печать без присмотра на неделю</p>
              </div>
            </div>
            <div class="bg-indigo-500/10 border border-dashed border-red-400 rounded-lg p-4 text-sm">
              <span class="font-medium">Короче:</span> Не делайте так, если не готовы к последствиям. Юристы тоже любят 3D-печать, но предпочитают «печатать» исковые заявления.
            </div>
          </div>

          <!-- collaboration -->
          <div class="bg-slate-800 p-6 rounded-xl space-y-4 ring-1 ring-white/5">
            <div class="flex items-center gap-3">
              <i data-lucide="git-pull-request" class="w-8 h-8 text-fuchsia-400"></i>
              <h3 class="text-xl font-semibold tracking-tight text-white">Хотите улучшить? Добро пожаловать!</h3>
            </div>
            <p>Нашли баг? Придумали фичу? Сделали fork?</p>
            <div class="flex flex-col sm:flex-row gap-4 text-sm">
              <div class="flex-1 bg-indigo-500/10 rounded-lg p-4 space-y-2">
                <div class="flex items-center gap-2 font-medium">
                  <i data-lucide="send" class="w-5 h-5 text-fuchsia-400"></i>Присылайте идеи
                </div>
                <p>Мы их будем их читать и собирать. У нас есть для этого специальная желтая папка</p>
              </div>
              <div class="flex-1 bg-indigo-500/10 rounded-lg p-4 space-y-2">
                <div class="flex items-center gap-2 font-medium">
                  <i data-lucide="code-2" class="w-5 h-5 text-fuchsia-400"></i>Делитесь кодом
                </div>
                <p>Ваши правки могут попасть в основную ветку с указанием авторов.</p>
              </div>
            </div>
            <p class="text-center italic text-indigo-300 text-xs">Совместная разработка — как печать огромной модели на нескольких принтерах. Результат стоит того!</p>
          </div>

        </div>
      </section>

      <!-- buttons -->
      <section id="Start" class="text-center space-y-4 reveal">
        <div class="flex justify-center gap-6 flex-wrap">
          <button id="allowConsentBtn" class="relative inline-flex items-center gap-2 bg-gradient-to-r from-indigo-500 to-fuchsia-500 text-white font-semibold tracking-tight px-10 py-4 rounded-full transition-transform duration-300 hover:-translate-y-1 shadow-lg">
            <i data-lucide="check-circle" class="w-6 h-6"></i>ПРИНЯТЬ УСЛОВИЯ И НАЧАТЬ
          </button>
          <button id="denyConsentBtn" class="relative inline-flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white font-semibold tracking-tight px-8 py-4 rounded-full transition-transform duration-300 hover:-translate-y-1 shadow-lg">
            <i data-lucide="x-circle" class="w-6 h-6"></i>НЕ СОГЛАСЕН
          </button>
        </div>

        <div class="relative max-w-lg mx-auto">
          <div id="acceptHint" class="absolute inset-x-0 -bottom-12 italic text-indigo-300 rounded-xl text-sm leading-relaxed opacity-0 pointer-events-none transition-opacity duration-300">
            Нажимая кнопку, вы подтверждаете, что прочитали и поняли условия. Это как нажать «Старт печати» — дальше всё зависит от вас!
          </div>
          <div id="declineHint" class="absolute inset-x-0 -bottom-12 italic text-indigo-300 rounded-xl text-sm leading-relaxed opacity-0 pointer-events-none transition-opacity duration-300">
            Если вы не согласны с условиями, вы не сможете продолжить и использовать сервис
          </div>
        </div>
      </section>
      <section id="End" class="text-center space-y-4 reveal">
        <div class="flex justify-center gap-6 flex-wrap">
          <button id="consetModalCloseBtn" class="relative inline-flex items-center gap-2 bg-gradient-to-r from-indigo-500 to-fuchsia-500 text-white font-semibold tracking-tight px-10 py-4 rounded-full transition-transform duration-300 hover:-translate-y-1 shadow-lg">
            <i data-lucide="check-circle" class="w-6 h-6"></i>Закрыть условия использования
          </button>
        </div>

        <div class="relative max-w-lg mx-auto">
          <div id="closeHint" class="absolute inset-x-0 -bottom-12 italic text-indigo-300 rounded-xl text-sm leading-relaxed opacity-0 pointer-events-none transition-opacity duration-300">
            Вы уже приняли условия использования. Приятной работы!
          </div>
        </div>
      </section>
      <div class="space-y-10"></div>
    </div>
  </div>

  <!-- CAMERA SETTINGS MODAL -->
  <div id="cameraSettingsModal" class="fixed inset-0 invisible opacity-0 transition-all duration-300 flex items-center justify-center bg-black/70 backdrop-blur-sm" aria-modal="true" aria-labelledby="cameraSettingsTitle" aria-hidden="true">
    <div class="relative modal-glass rounded-2xl w-full h-full border border-fuchsia-700/25 flex flex-col modal-fade-in overflow-hidden">
      <!-- Header с кнопками -->
      <div class="absolute top-4 right-4 flex flex-col items-center gap-2">
        <div class="action-icon expand-icon glass-btn" title="Развернуть" tabindex="0" role="button">
          <i class="fas fa-expand"></i>
        </div>
        <div class="action-icon manage-icon glass-btn" title="Управление" tabindex="0" role="button">
          <i class="fas fa-cog"></i>
        </div>
      </div>
      
      <!-- Страница klpper -->
      <div class="flex-1 overflow-y-auto p-2">
        <!-- Здесь будет содержимое klipper -->
      </div>
    </div>
  </div>
  <div id="ants" style="z-index: 101;">  </div>
<script>
// === CONFIGURATION ===
const Config = {
  defaultCameras: [
    { ip: '193', stream: '', name: 'ТкачМатерии' },
    { ip: '194', stream: '', name: 'КузницаСлоев' },
    { ip: '195', stream: '', name: 'Пластикоформовщик' }
  ],

  defaultSettings: {
    // Цветовая схема
    color1: '#667eea',
    color2: '#471b74',
    colorIntOver: 1.5,
    errorNotificationColor: '#ff4d4d',
    systemNotificationColor: '#4ade80',
    notificationOpacity: '0.3',

    // Загрузка
    loader: {
      hide: false,
      bgColor: '#111111',
      opacity: '1',
      offFullCheckbox: false
    },

    // Сетка
    grid: {
      columns: 3
    },

    // Шапка
    header: {
      text: 'Активные принтера',
      hidden: false,
      bgColor: '#000000',
      bgOpacity: 0.4,
      textColor: '#ffffff'
    },

    // Разделители
    dividerColor: '#ba88e2',
    dividerThickness: 2,
    dividerAlign: 'center',
    dividerWidth: 96,
    enableDividers: false,

    // Размер текста
    namedDriv: 0.9,

    // Интерфейс
    interfaceWidth: 1400
  },

  colors: {
    dammyColor: '#667eea',
    dammyColor2: '#471b74'
  },

  performance: {
    debounceDelay: 100,
    throttleDelay: 16,
    maxRetries: 3,
    retryDelay: 1000
  }
};


// Инициализация объекта Elements для доступа к DOM-элементам
const Elements = {
  // Containers
  cameraContainer: document.getElementById('cameraContainer'),
  settingsPanel: document.getElementById('settingsPanel'),
  mainInterfaceContainer: document.getElementById('mainInterfaceContainer'),
  mainInterfaceContainerCameras: document.getElementById('mainInterfaceContainerCameras'),

  // Buttons
  openSettingsBtn: document.getElementById('openSettingsBtn'),
  closeSettingsBtn: document.getElementById('closeSettingsBtn'),
  refreshCamerasBtn: document.getElementById('refreshCamerasBtn'),
  applyChangesBtn: document.getElementById('applyChangesBtn'),
  resetSettingsBtn: document.getElementById('resetSettingsBtn'),
  helpBtn: document.getElementById('helpBtn'),
  savePositionBtn: document.getElementById('savePositionBtn'),
  addCameraBtn: document.getElementById('addCameraBtn'),
  addDammyCameraBtn: document.getElementById('addDammyCameraBtn'),
  consetModalBtn: document.getElementById('consetModalBtn'),
  consetModalCloseBtn: document.getElementById('consetModalCloseBtn'),
  allowConsentBtn: document.getElementById('allowConsentBtn'),
  denyConsentBtn: document.getElementById('denyConsentBtn'),
  confirmResetBtn: document.getElementById('confirmResetBtn'),
  cancelResetBtn: document.getElementById('cancelResetBtn'),
  closeHelpBtn: document.getElementById('closeHelpModal'),

  // Inputs
  gridColumnsInput: document.getElementById('gridColumns'),
  color1Input: document.getElementById('color1'),
  color2Input: document.getElementById('color2'),
  colorIntOverInput: document.getElementById('colorIntOver'),
  errorNotificationColorInput: document.getElementById('errorNotificationColor'),
  systemNotificationColorInput: document.getElementById('systemNotificationColor'),
  notificationOpacityInput: document.getElementById('notificationOpacity'),
  headerTextInput: document.getElementById('headerText'),
  hideHeaderCheckbox: document.getElementById('hideHeaderCheckbox'),
  headerBgColorInput: document.getElementById('headerBgColor'),
  headerBgOpacityInput: document.getElementById('headerBgOpacity'),
  headerTextColorInput: document.getElementById('headerTextColor'),
  interfaceWidth: document.getElementById('interfaceWidth'),
  interfaceWidthInput: document.getElementById('interfaceWidthInput'),
  interfaceWidthValue: document.getElementById('interfaceWidthValue'),
  dividerColorInput: document.getElementById('dividerColor'),
  dividerThicknessInput: document.getElementById('dividerThickness'),
  dividerAlignInput: document.getElementById('dividerAlign'),
  dividerWidthInput: document.getElementById('dividerWidth'),
  dividerWidthValue: document.getElementById('dividerWidthValue'),
  namedDrivInput: document.getElementById('namedDriv'),
  namedDrivValue: document.getElementById('namedDrivValue'),
  enableDividersCheckbox: document.getElementById('enableDividersCheckbox'),
  hideLoaderCheckbox: document.getElementById('hideLoaderCheckbox'),
  loaderBgColorInput: document.getElementById('loaderBgColor'),
  loaderOpacityInput: document.getElementById('loaderOpacity'),
  offFullCheckbox: document.getElementById('offFullCheckbox'),

  // Экспорт/импорт
  exportBtn: document.getElementById('exportBtn'),
  importFile: document.getElementById('importFile'),
  importExportBlock: document.getElementById('importExportBlock'),
  importExportBtnBlock: document.getElementById('importExportBtnBlock'),
  showImportExportBtn: document.getElementById('showImportExportBtn'),
  closeImportExportBtn: document.getElementById('closeImportExportBtn'),

  // Меню сетки в настройках
  mainWrap:document.getElementById('mainSectionWrap'),
  openBtn:document.getElementById('openSettingsBtnModal'),
  modal:document.getElementById('settingsModal'),
  modalHolder:document.getElementById('modalHolder'),
  tableWrapper:document.getElementById('tableWrapper'),
  tbody:document.getElementById('camerasTableBody'),
  indicator:document.getElementById('dropIndicator'),

  // Others
  overlay: document.getElementById('overlay'),
  mainHeader: document.getElementById('mainHeader'),
  headerBar: document.getElementById('headerBar'),
  headerTitle: document.getElementById('headerTitle'),
  notificationContainer: document.getElementById('notificationContainer'),
  consentModal: document.getElementById('consentModal'),
  resetConfirmModal: document.getElementById('resetConfirmModal'),
  toolbar: document.getElementById('toolbar'),
  toolbarContainer: document.getElementById('toolbarContainer'),
  helpModal: document.getElementById('helpModal'),
  modalDialog: document.getElementById('modalDialog'),
  accordionList: document.getElementById('accordionList'),
};

// === STATE ===
let State = {
  floatingToolbar: null,
  allowLocalStorage: false,
};
let suppressNotifications = false;
let pendingRestores = 0;


// === Дебаунс ===
function debounce(func, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
}
const debouncedUpdateDividers      = debounce(updateHorizontalDividers, 25);
const debouncedSave                = debounce(saveToLocalStorage,      100);
const debouncedUpdateInterfaceWidth = debounce(updateInterfaceWidth,    15);
const debouncedSaveOnDragEnd       = debounce(saveToLocalStorage,      150);
const debouncedUpdateNotificationOpacity = debounce(updateNotificationOpacity, 100);

[Elements.color1Input, Elements.color2Input, Elements.errorNotificationColorInput,
 Elements.headerBgColorInput, Elements.dividerColorInput].forEach(input => {
    input.addEventListener('input', debouncedSave);
});
Elements.interfaceWidthInput.addEventListener('input', debouncedUpdateInterfaceWidth);
Elements.notificationOpacityInput.addEventListener('input', debouncedUpdateNotificationOpacity);

// === Троттлинг ===
function throttle(func, delay) {
  let lastCall = 0;
  let timeoutId;
  let lastArgs;

  return function throttled(...args) {
    const now = Date.now();
    const remaining = delay - (now - lastCall);

    lastArgs = args;
    if (remaining <= 0) {
      clearTimeout(timeoutId);
      timeoutId = null;
      lastCall = now;
      func.apply(this, args);
    } else if (!timeoutId) {
      timeoutId = setTimeout(() => {
        lastCall = Date.now();
        timeoutId = null;
        func.apply(this, lastArgs);
      }, remaining);
    }
  };
}
// === TASK SEQUENCE ===
let positionUpdateQueue = [];
let isProcessingQueue = false;
let notificationHeight = 48;
const POSITION_UPDATE_DELAY = 100; // мс

// === INITIALIZATION ===
function init() {
  setupEventListeners();
  updateHeader();
  updateToolbarColors()
  updateGrid();
  updateInterfaceWidth();
  updateLoader();
  updateToolbarVisibility();
  updateActionIconColors();

  if (!localStorage.getItem('printerCamsV2Consent')) {
    showConsent();
  } else {
    State.allowLocalStorage = true;
    if (!loadFromLocalStorage()) {
      loadCameras(Config.defaultCameras);
      renderCameraTable(Config.defaultCameras);
    }
    renderCameras();
    // === NOTIFICATION BUTTON HANDLERS ===
    if (expandNotificationsBtn) {
      expandNotificationsBtn.addEventListener('click', () => {
        const collapsed = getCollapsedNotifications();
        if (collapsed.length > 0) {
          collapsed.forEach(notification => {
              expandNotification(notification);
          });
          notificationActions.classList.remove('show');
        }
    });
  }

    if (closeAllNotificationsBtn) {
      closeAllNotificationsBtn.addEventListener('click', () => {
        const allNotifications = document.querySelectorAll('.notification');
        allNotifications.forEach(notification => {
          if (!notification.classList.contains('fade-out-up')) {
            notification.classList.add('fade-out-up');
            notification.addEventListener('animationend', () => {
              _removeNotificationElement(notification);
            }, { once: true });
          }
        });
        notificationActions.classList.add('hidden');
      });
    }
    debouncedUpdateDividers();
  }

  Elements.headerTextColorInput.addEventListener('input', () => {
    updateHeader();
    updateToolbarColors();
  });
  const consentModal = document.getElementById('consentModal');
  if (consentModal && !consentModal.classList.contains('hidden')) {
    document.getElementById('loaderOverlay')?.classList.add('hidden');
  }
}

function updateToolbarColors() {
  const color1 = Elements.color1Input.value;
  const color2 = Elements.color2Input.value;
  const iColor = Elements.headerTextColorInput.value;

    // Конвертируем HEX → RGB
  const rgb1 = hexToRgbStr(color1);
  const rgb2 = hexToRgbStr(color2);
  const rgbi = hexToRgbStr(iColor);

  document.documentElement.style.setProperty('--base-color1', rgb1);
  document.documentElement.style.setProperty('--base-color2', rgb2);
  document.documentElement.style.setProperty('--toolbar-icon-color', rgbi);
}

// Для динамического изменения цвета кнопока
function updateActionIconColors() {
  const color1 = getComputedStyle(document.documentElement).getPropertyValue('--base-color1').trim();
  const color2 = getComputedStyle(document.documentElement).getPropertyValue('--base-color2').trim();

  const rgb1 = parseRGB(color1);
  const rgb2 = parseRGB(color2);

  if (!rgb1 || !rgb2) {
    console.error("Не удалось распарсить один из цветов.");
    return;
  }

  // Средний цвет
  const avgRgb = {
    r: Math.round((rgb1.r + rgb2.r) / 2),
    g: Math.round((rgb1.g + rgb2.g) / 2),
    b: Math.round((rgb1.b + rgb2.b) / 2)
  };

  document.documentElement.style.setProperty('--base-color-rgb', `${avgRgb.r} ${avgRgb.g} ${avgRgb.b}`);

  // Вычисляем HSV для среднего цвета
  const [h1, s1, v1] = rgbToHsv(avgRgb.r, avgRgb.g, avgRgb.b);

  // Определяем text-rgb на основе Value
  const textRgb = v1 < 70 ? '255 255 255' : '0 0 0';
  const textRgbW1 = v1 < 90 ? '255 255 255' : '0 0 0';
  const textRgbInvert = v1 < 70 ? '0 0 0' : '255 255 255';
  document.documentElement.style.setProperty('--text-rgb', textRgb);
  document.documentElement.style.setProperty('--textW1-rgb', textRgbW1);
  document.documentElement.style.setProperty('--textInvert-rgb', textRgbInvert);

  // Tetrad противоположные цвета
  const tetradColor1 = { r: Math.min(255, 255 - rgb1.r), g: Math.min(255, 255 - rgb1.g), b: Math.min(255, 255 - rgb1.b) };
  const tetradColor2 = { r: Math.min(255, 255 - rgb2.r), g: Math.min(255, 255 - rgb2.g), b: Math.min(255, 255 - rgb2.b) };

  document.documentElement.style.setProperty('--tetrad-color1-rgb', `${tetradColor1.r} ${tetradColor1.g} ${tetradColor1.b}`);
  document.documentElement.style.setProperty('--tetrad-color2-rgb', `${tetradColor2.r} ${tetradColor2.g} ${tetradColor2.b}`);

  // Получаем коэффициент для тонового сдвига
  const shiftFactor = parseFloat(document.getElementById('colorIntOver')?.value || '1.2');

  // Функция для изменения тона (светлее/темнее)
  function adjustTone(rgb, factor) {
    return {
      r: Math.min(255, Math.max(0, Math.round(rgb.r * factor + 0.5))),
      g: Math.min(255, Math.max(0, Math.round(rgb.g * factor + 0.5))),
      b: Math.min(255, Math.max(0, Math.round(rgb.b * factor + 0.5)))
    };
  }

  // Цветовые группы для генерации оттенков
  const colorGroups = {
    base1: rgb1,
    base2: rgb2,
    avg: avgRgb,
    tetrad1: tetradColor1,
    tetrad2: tetradColor2
  };

  // Генерация светлых и темных оттенков
  for (const [name, rgb] of Object.entries(colorGroups)) {
    const light = adjustTone(rgb, shiftFactor);
    const dark = adjustTone(rgb, 1 / shiftFactor);

    document.documentElement.style.setProperty(`--${name}-light-rgb`, `${light.r} ${light.g} ${light.b}`);
    document.documentElement.style.setProperty(`--${name}-dark-rgb`, `${dark.r} ${dark.g} ${dark.b}`);
  }

  // Преобразование в HSV для дополнительных модификаций
  const [h, s, v] = rgbToHsv(avgRgb.r, avgRgb.g, avgRgb.b);

  // Генерация новых цветов на основе HSV
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  const hsvShifts = {
    shiftedRightDark:   [clamp(h - 1, 0, 359), clamp(s + 5, 0, 100), clamp(v - 30, 0, 100)],
    shiftedLightWight:  [clamp(h - 5, 0, 359), clamp(s - 30, 0, 100), clamp(v + 5, 0, 100)],
    stickyHeader:       [clamp(h - 25, 0, 359), clamp(s - 10, 0, 100), clamp(v - 63, 0, 100)],
    scrollableTableH:   [clamp(h + 10, 0, 359), clamp(s + 5, 0, 100), clamp(v + 5, 0, 100)],
    scrollableTableB:   [clamp(h - 10, 0, 359), clamp(s + 5, 0, 100), clamp(v + 5, 0, 100)],
    shedow:             [clamp(h + 25, 0, 359), clamp(s - 25, 0, 100), clamp(v + 65, 0, 100)],
  };

  // Конвертируем HSV обратно в RGB и устанавливаем CSS-переменные
  for (const [key, [hVal, sVal, vVal]] of Object.entries(hsvShifts)) {
    const rgb = hsvToRgb(hVal, sVal, vVal);
    document.documentElement.style.setProperty(`--${key}-rgb`, `${rgb[0]} ${rgb[1]} ${rgb[2]}`);
  }

  // Обновляем цвет иконок действий
  document.querySelectorAll('.action-icon i, .action-icon svg').forEach(icon => {
    icon.style.color = `rgb(${avgRgb.r} ${avgRgb.g} ${avgRgb.b})`;
  });
  return avgRgb;
}

// Вспомогательная функция для конвертации HEX в RGB
function hexToRgb(hex) {
  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
  
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

// Вспомогательная функция для конвертации RGB → HSV
function rgbToHsv(r, g, b) {
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, v = max;

  const d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // ахроматический
  } else {
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
      default: h = 0;
    }
    h /= 6;
  }

  return [h * 360, s * 100, v * 100];
}

function hexToRgbStr(hex) {
  const rgb = hexToRgb(hex);
  if (!rgb) return null; // Если не удалось распарсить цвет
  return `${rgb.r} ${rgb.g} ${rgb.b}`;
}

// Переводит HSV → RGB
function hsvToRgb(h, s, v) {
  h = h % 360;
  h = h < 0 ? 360 + h : h;
  h /= 60;
  s /= 100;
  v /= 100;

  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);

  let r, g, b;
  switch(i) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: r = g = b = 0; break;
  }

  return [
    Math.round(r * 255),
    Math.round(g * 255),
    Math.round(b * 255)
  ];
}

// Вспомогательная функция для парсинга строки "R G B"
function parseRGB(rgbStr) {
  const parts = rgbStr.split(/\s+/).map(Number);
  if (parts.length === 3 && parts.every(n => !isNaN(n) && n >= 0 && n <= 255)) {
    return { r: parts[0], g: parts[1], b: parts[2] };
  }
  return null;
}

// Отсдеживаем изменение прозрачности
function updateNotificationOpacity() {
  const opacityInput = Elements.notificationOpacityInput;
  let opacityValue = parseFloat(opacityInput.value);

  if (isNaN(opacityValue) || opacityValue < 0 || opacityValue > 1) {
    opacityValue = 0.2; // Значение по умолчанию
  }

  const notifications = document.querySelectorAll('.notification');

  notifications.forEach(notification => {
    const isSystem = notification.classList.contains('system');
    const isError = notification.classList.contains('error');
    const { color } = getNotificationStyles(isSystem || isError ? isSystem : false);

    const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if (!rgbaMatch) return;

    const [r, g, b] = rgbaMatch.slice(1, 4).map(Number);
    notification.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacityValue})`;
  });

  saveToLocalStorage();
}
// === EVENT LISTENERS ===

function setupEventListeners() {
  window.addEventListener('resize', debounce(() => {
    updateInterfaceWidth();
  }, 100));
  const notification = document.getElementById('settingsChangedNotification');

  // Все поля настроек
  const settingInputs = document.querySelectorAll(`#settingsPanel input, #settingsPanel select, .accordion-checkbox`);

  // Показываем уведомление
  function showSettingsChangedNotification() {
    const notification = document.getElementById('settingsChangedNotification');
    if (!notification) {
        return;
    }

    // Сначала удаляем класс hidden
    notification.classList.remove('hidden');
    
    // Используем requestAnimationFrame для гарантированной анимации
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        notification.style.transform = 'translateY(10px)';
        notification.style.opacity = '1';
      });
    });
  }

  function hideSettingsChangedNotification() {
    const notification = document.getElementById('settingsChangedNotification');
    if (!notification) return;

    notification.style.transform = 'translateY(-80px)';
    notification.style.opacity = '0';
    
    notification.addEventListener('transitionend', () => {
      notification.classList.add('hidden');
    }, { once: true });
  }

  // Подписываемся на изменения полей
  settingInputs.forEach(input => {
    // Используем несколько типов событий для надежности
    ['input', 'change', 'blur'].forEach(eventType => {
      input.addEventListener(eventType, () => {
        showSettingsChangedNotification();
      });
    });
  });

  // При нажатии на "Применить изменения"
  const applyChangesBtn = document.getElementById('applyChangesBtn');
  if (applyChangesBtn) {
    applyChangesBtn.addEventListener('click', () => {
      hideSettingsChangedNotification();
    });
  }

  // При нажатии на крестик уведомления в настройках
  const closeNotificationBtn = document.getElementById('closeNotificationBtn');
  if (closeNotificationBtn) {
    closeNotificationBtn.addEventListener('click', () => {
      hideSettingsChangedNotification();
    });
  }

  // Settings Panel
  // Слушатель нажания на кнопку settings
  Elements.openSettingsBtn.addEventListener('click', openPanel);
  Elements.closeSettingsBtn.addEventListener('click', closePanel);
  Elements.overlay.addEventListener('click', closePanel);
      document.addEventListener('keydown', e => {
    if (e.key === 'Escape') closePanel();
  });
  Elements.settingsPanel.addEventListener('click', e => e.stopPropagation());
  // Открытие/закрытие панели с анимацией
  function openPanel() {
    const accordions = document.querySelectorAll('.accordion');
    accordions.forEach(acc => {
      closeAccordion(acc);
    });
    setTimeout(() => {
      _openPanel();
    }, 400);
  }
  
  function _openPanel() {
    // Сбрасываем полностью панель, чтобы анимация сработала заново
    Elements.settingsPanel.style.display = 'block';
    
    // Принудительно "обнуляем" трансформацию и прозрачность
    Elements.settingsPanel.classList.remove('panel-appear-active');
    Elements.settingsPanel.classList.add('panel-appear');

    // Обнуляем стили всех элементов
    const items = Elements.settingsPanel.querySelectorAll('.accordion, #importExportBtnBlock');
    items.forEach(item => {
      item.classList.remove('active');
      item.style.opacity = '0';
      item.style.transform = 'translateZ(30px)';
    });

    // Принудительный перерасчёт стилей — КЛЮЧЕВОЙ ШАГ!
    void Elements.settingsPanel.offsetWidth;

    // Включаем overlay
    Elements.overlay.style.backdropFilter = 'blur(8px)';
    Elements.overlay.style.transition = 'opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), backdrop-filter 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

    // Запускаем анимацию
    requestAnimationFrame(() => {
      // Анимация overlay
      Elements.overlay.style.opacity = '1';

      // Анимация панели
      Elements.settingsPanel.classList.add('panel-appear-active');

      // Последовательная анимация элементов
      items.forEach((item, index) => {
        setTimeout(() => {
          item.classList.add('active');
          item.style.opacity = '1';
          item.style.transform = 'translateZ(0)';
        }, 200 + (index * 100));
      });
    });
  }

  function closePanel() {
    const items = Elements.settingsPanel.querySelectorAll('.fade-slide-in');

    // 1. Убираем активность у всех элементов с анимацией
    items.forEach((item, index) => {
      item.classList.remove('active');
      item.style.opacity = '0';
      item.style.transform = 'translateZ(30px)';
    });

    // 2. Ждём окончания анимации элементов (например, 300ms)
    setTimeout(() => {
      // 3. Анимируем панель "закрытие"
      Elements.settingsPanel.classList.remove('panel-appear-active');

      // 4. Ждём окончания анимации панели
      const handleTransitionEnd = () => {
        // 5. Скрываем панель
        Elements.settingsPanel.style.display = 'none';

        // 6. Восстанавливаем начальное состояние элементов
        items.forEach(item => {
          item.style.opacity = '';
          item.style.transform = '';
        });

        // 7. Убираем классы у панели
        Elements.settingsPanel.classList.remove('panel-appear');

        // 8. Убираем overlay
        Elements.overlay.style.opacity = '0';
        Elements.overlay.style.backdropFilter = 'blur(0px)';
        Elements.overlay.addEventListener('transitionend', function onOverlayTransitionEnd() {
          Elements.overlay.removeEventListener('transitionend', onOverlayTransitionEnd);
          Elements.overlay.style.pointerEvents = 'none';
        }, { once: true });;

        Elements.settingsPanel.removeEventListener('transitionend', handleTransitionEnd);
      };

      Elements.settingsPanel.addEventListener('transitionend', handleTransitionEnd);

    }, 300); // Задержка для завершения анимации элементов

    hideImportExport();
  }
  
  // Добавляем начальное состояние для элементов панели
  document.addEventListener('DOMContentLoaded', () => {
    initAccordionCheckboxes();

    const notification = document.getElementById('settingsChangedNotification');
    if (notification) {
        notification.style.display = 'none';
        notification.classList.add('hidden');
    }

    const items = Elements.settingsPanel.querySelectorAll('.panel-item');
    items.forEach(item => {
      item.style.opacity = '0';
      item.style.transform = 'translateZ(-50px)';
      item.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
    });
  });
  
  // Добавляем эффект при наведении на элементы
  document.querySelectorAll('.panel-item').forEach(item => {
    item.addEventListener('mouseenter', () => {
      item.style.transform = 'translateZ(50px)';
    });
    item.addEventListener('mouseleave', () => {
      item.style.transform = 'translateZ(0)';
    });
  });
  
  // Accordion animation/collapse
  let accordionStates = [];
  function setAccordionDisabled(disabled) {
    document.querySelectorAll('.accordion').forEach((acc, i) => {
      if (disabled) {
        // Save state and close
        if (acc.classList.contains('accordion-open')) accordionStates[i] = true;
        else accordionStates[i] = false;
        acc.classList.add('accordion-disabled');
        acc.querySelector('.accordion-content').style.maxHeight = '0px';
      } else {
        acc.classList.remove('accordion-disabled');
        if (accordionStates[i]) { // Restore
          acc.classList.add('accordion-open');
          const content = acc.querySelector('.accordion-content');
          content.style.display = 'block';
          let h = content.scrollHeight;
          content.style.maxHeight = h + 'px';
          setTimeout(() => {
            content.style.opacity = '1';
          },  10);

        }
      }
    });
  }
  
  document.querySelectorAll('.accordion').forEach((acc) => {
    const btn = acc.querySelector('.accordion-toggle');
    const content = acc.querySelector('.accordion-content');

    content.style.maxHeight = '0';

    btn.addEventListener('click', (event) => {
      // Игнорируем клик по кастомному чекбоксу
      if (event.target.closest('.custom-checkbox-container')) return;

      if (acc.classList.contains('accordion-disabled')) return;

      const isOpen = acc.classList.contains('accordion-open');

      if (isOpen) {
        closeAccordion(acc);
        updateAccordionCheckboxState(acc, false); // Чекбокс выключен
      } else {
        // Закрываем другие аккордеоны
        document.querySelectorAll('.accordion.accordion-open').forEach(openAcc => {
          closeAccordion(openAcc);
          updateAccordionCheckboxState(openAcc, false);
        });

        // Открываем текущий
        acc.classList.add('accordion-open');
        content.style.display = 'block';
        let h = content.scrollHeight + 30;
        content.style.maxHeight = '0';
        setTimeout(() => {
          content.style.maxHeight = h + 'px';
          content.style.opacity = '1';
        }, 10);

        updateAccordionCheckboxState(acc, true); // Чекбокс включен
      }
    });
  });

  function closeAccordion(acc) {
    const content = acc.querySelector('.accordion-content');
    acc.classList.remove('accordion-open');
    content.style.maxHeight = '0';
    content.style.opacity = '0';
    setTimeout(() => {
      content.style.display = 'none';
    }, 400);
  }

  function initAccordionCheckboxes() {
    document.querySelectorAll('.accordion').forEach(acc => {
      const checkbox = acc.querySelector('.accordion-checkbox');
      const accordionButton = acc.querySelector('.accordion-toggle');

      if (!checkbox || !accordionButton) return;

      checkbox.addEventListener('click', function (e) {
        // Имитируем клик на кнопке аккордеона
        accordionButton.click();
      });
    });
  }

  // Обновляем состояние чекбокса при открытии/закрытии аккордеона
  function updateAccordionCheckboxState(acc, isChecked) {
    const checkbox = acc.querySelector('.accordion-checkbox');
    if (checkbox) {
      checkbox.checked = isChecked;
    }
  }
  
  // Состояние ширины разделителя
  Elements.dividerWidthInput.addEventListener('input', e => 
    Elements.dividerWidthValue.textContent = e.target.value + '%'
  );

  // Состояние размера имени в карточках
  Elements.namedDrivInput.addEventListener('input', e => { 
    Elements.namedDrivValue.textContent = e.target.value + 'rem'
    localStorage.setItem('namedDrivValue', namedDrivInput.value);
    updateCameraTitleFontSize();
  });
  
  // Состояние ширины
  Elements.interfaceWidthInput.addEventListener('input', e => {
    const value = Math.min(Math.max(parseInt(e.target.value), 800), 1920);
    if (!isNaN(value)) {
        Elements.interfaceWidthInput.value = value;
        debouncedUpdateInterfaceWidth();
    }
  });
  
  Elements.color1Input.addEventListener('input', updateToolbarColors);
  Elements.color2Input.addEventListener('input', updateToolbarColors);
  updateToolbarColors();
  
  // Custom checkbox styling
  document.querySelectorAll('.custom-checkbox input[type="checkbox"]').forEach(cb => {
    function updateClass() {
      if (this.checked) {
        this.parentElement.classList.add('checked');
      } else {
        this.parentElement.classList.remove('checked');
      }
    }

    cb.addEventListener('change', updateClass);
    cb.addEventListener('DOMContentLoaded', updateClass); // Для начального состояния
  });
  
  // Импорт/Экспорт show/hide logic
  function showImportExport() {
    // Закрываем все открытые аккордеоны принудительно
    document.querySelectorAll('.accordion.accordion-open').forEach(acc => {
      closeAccordion(acc);
    });

    // Отключение аккордеонов
    setAccordionDisabled(true);
    Elements.importExportBtnBlock.style.display = "none";
    Elements.importExportBlock.style.display = "block";
    
    // Добавляем отключение кнопок
    Elements.applyChangesBtn.classList.add('btn-disabled');
    Elements.resetSettingsBtn.classList.add('btn-disabled');
    
    setTimeout(() => {
      Elements.importExportBlock.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-10', 'scale-95');
      Elements.importExportBlock.classList.add('opacity-100');
    }, 10);
    
    Elements.importExportBlock.classList.add('pointer-events-auto');
  }
  
  // Модифицируем функцию hideImportExport
  function hideImportExport() {
    // Существующий код
    setAccordionDisabled(false);
    
    // Включаем кнопки обратно
    Elements.applyChangesBtn.classList.remove('btn-disabled');
    Elements.resetSettingsBtn.classList.remove('btn-disabled');
    
    Elements.importExportBlock.classList.remove('opacity-100');
    Elements.importExportBlock.classList.add('opacity-0', 'pointer-events-none', 'translate-y-10', 'scale-95');
    
    setTimeout(() => {
      Elements.importExportBlock.style.display = "none";
      Elements.importExportBtnBlock.style.display = "";
    }, 400);
  }
  
  Elements.showImportExportBtn.addEventListener('click', showImportExport);
  Elements.closeImportExportBtn.addEventListener('click', hideImportExport);
  
  // Drag and drop для модуля импорта
  const dropzone = Elements.importExportBlock.querySelector('.dropzone');
  const importFileInput = Elements.importFile;
  
  dropzone.addEventListener('dragover', e => {
    e.preventDefault();
    dropzone.classList.add('dragover');
  });
  
  dropzone.addEventListener('dragleave', e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
  });
  
  dropzone.addEventListener('drop', e => {
    e.preventDefault();
    dropzone.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file) {
      handleImportFile(file);
    }
  });
  
  importFileInput.addEventListener('change', e => {
    if (e.target.files[0]) {
      handleImportFile(e.target.files[0]);
    }
  });
  // Добавьте этот код в функцию setupEventListeners()
  Elements.offFullCheckbox.addEventListener('change', (e) => {
      const isChecked = e.target.checked;
      
      // Сохраняем в localStorage
      if (State.allowLocalStorage) {
          const settings = JSON.parse(localStorage.getItem('printerCamsV2') || '{}');
          settings.loader = settings.loader || {};
          settings.loader.offFullCheckbox = isChecked;
          localStorage.setItem('printerCamsV2', JSON.stringify(settings));
      }
  });
  function handleImportFile(file) {
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);

        // --- 1. Очищаем старые данные ---
        Object.keys(localStorage).forEach(k => localStorage.removeItem(k));

        // --- 2. Загружаем настройки ---
        if (data.settings && typeof data.settings === 'object') {
          Object.entries(data.settings).forEach(([key, value]) => {
            localStorage.setItem(key, typeof value === 'object' ? JSON.stringify(value) : value);
          });
        }

        // --- 3. Загружаем камеры ---
        if (Array.isArray(data.cameras)) {
          loadCameras(data.cameras);          // обновляем внутренний массив
          renderCameraTable(data.cameras);    // перерисовываем таблицу
        }

        // --- 4. Применяем всё ---
        loadFromLocalStorage(); // перезагружает UI
        renderCameras();
        updateInterfaceWidth();
        updateToolbarColors();
        updateHeader();
        debouncedUpdateDividers();

        enqueueNotification('Все настройки и камеры успешно импортированы!', 'system');
        hideImportExport();
        location.reload(); // надежный способ применить всё
      } catch (err) {
        console.error(err);
        alert('Ошибка импорта: файл повреждён или имеет неверный формат.');
      }
    };
    reader.readAsText(file);
  }
  
  // Экспорт настроек
  Elements.exportBtn.addEventListener('click', () => {
    // 1. Собираем все ключи из localStorage
    const allSettings = {};
    Object.keys(localStorage).forEach(key => {
      try {
        allSettings[key] = JSON.parse(localStorage.getItem(key));
      } catch {
        allSettings[key] = localStorage.getItem(key); // fallback для строк
      }
    });

    // 2. Собираем камеры в актуальном порядке
    const cameras = getCameraTableData(); // уже возвращает {ip, stream, name, order}

    const exportData = {
      settings: allSettings,
      cameras
    };

    // 3. Скачиваем JSON
    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
      type: 'application/json'
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'printerCamsV2_full_settings.json';
    a.click();
    URL.revokeObjectURL(url);
  });
    
  // Кнопки "Применить" и "Сбросить"
  Elements.resetSettingsBtn.addEventListener('click', () => {
    closePanel();
    Elements.resetConfirmModal.classList.remove('hidden');
  });

  Elements.cancelResetBtn.addEventListener('click', closeModal);
  Elements.resetConfirmModal.addEventListener('click', e => {
    if (!e.target.closest('.bg-white')) closeModal();
  });

  document.addEventListener('keydown', e => {
    if (e.key === 'Escape') closeModal();
  });

  // Функция восстановления  параметров на заводские
  Elements.confirmResetBtn.addEventListener('click', () => {
    if (State.allowLocalStorage) {
      // 🔥 удаляем ВСЁ
      localStorage.clear();
      localStorage.removeItem('printerCamsV2');
      localStorage.removeItem('printerCamsV2Consent');
    }
    closeModal();
  const s = Config.defaultSettings;

    Elements.color1Input.value = s.color1;
    Elements.color2Input.value = s.color2;
    Elements.colorIntOverInput.value = s.colorIntOver;
    Elements.errorNotificationColorInput.value = s.errorNotificationColor;
    Elements.systemNotificationColorInput.value = s.systemNotificationColor;
    Elements.notificationOpacityInput.value = s.notificationOpacity;
    Elements.hideLoaderCheckbox.checked = s.loader.hide;
    Elements.loaderBgColorInput.value = s.loader.bgColor;
    Elements.loaderOpacityInput.value = s.loader.opacity;
    Elements.offFullCheckbox.checked = s.loader.offFullCheckbox;
    Elements.gridColumnsInput.value = s.grid.columns;
    Elements.headerTextInput.value = s.header.text;
    Elements.hideHeaderCheckbox.checked = s.header.hidden;
    Elements.headerBgColorInput.value = s.header.bgColor;
    Elements.headerBgOpacityInput.value = s.header.bgOpacity;
    Elements.headerTextColorInput.value = s.header.textColor;
    Elements.interfaceWidth.value = s.interfaceWidth;
    Elements.interfaceWidthInput.value = s.interfaceWidth;
    Elements.dividerColorInput.value = s.dividerColor;
    Elements.dividerThicknessInput.value = s.dividerThickness;
    Elements.dividerAlignInput.value = s.dividerAlign;
    Elements.dividerWidthInput.value = s.dividerWidth;
    Elements.dividerWidthValue.textContent = s.dividerWidth + '%';
    Elements.enableDividersCheckbox.checked = s.enableDividers;
    Elements.namedDrivInput.value = s.namedDriv;
    Elements.namedDrivValue.textContent = s.namedDriv + 'rem';

    // Перезаписываем камеры из Config
    loadCameras(Config.defaultCameras);
    renderCameraTable(Config.defaultCameras);
    // Применяем изменения в UI
    updateHeader();
    updateToolbarColors();
    updateGrid();
    updateInterfaceWidth();
    updateToolbarVisibility();
    updateLoader();
    debouncedUpdateDividers();
    updateCameraTitleFontSize();
    // Сохраняем в localStorage
    saveToLocalStorage();
    // Перезагружаем страницу (опционально)
    location.reload();

  });

  // Help Modal
  Elements.helpBtn.addEventListener('click', () => Elements.helpModal.classList.remove('hidden'));
  Elements.closeHelpBtn.addEventListener('click', () => Elements.helpModal.classList.add('hidden'));
  Elements.helpModal.addEventListener('click', e => {
    if (!e.target.closest('.bg-white')) Elements.helpModal.classList.add('hidden');
  });

  // Grid Columns
  Elements.gridColumnsInput.addEventListener('input', () => {
    updateGrid();
    debouncedUpdateDividers();
    updateAntsVisibility();
  });

  Elements.interfaceWidthInput.addEventListener('input', e => {
    document.getElementById('interfaceWidthInput').value = e.target.value;
    debouncedUpdateInterfaceWidth();
  });

  document.getElementById('interfaceWidthInput').addEventListener('input', (e) => {
    const value = Math.min(Math.max(parseInt(e.target.value), 800), 1920);
    if (!isNaN(value)) {
      updateInterfaceWidth();
      saveToLocalStorage();
    }
  });


  Elements.namedDrivInput.addEventListener('input', (e) => {
    Elements.namedDrivValue.textContent = e.target.value + 'rem';
    debouncedUpdateDividers();
    updateCameraTitleFontSize();
    saveToLocalStorage();
  });
  // Divider Settings width sync
  [Elements.enableDividersCheckbox, Elements.dividerColorInput, Elements.dividerThicknessInput].forEach(input => {
    input.addEventListener('input', debouncedUpdateDividers);
  });
  Elements.dividerWidthInput.addEventListener('input', (e) => {
    Elements.dividerWidthValue.textContent = e.target.value + '%';
    debouncedUpdateDividers();
    saveToLocalStorage();
  });

  Elements.dividerAlignInput.addEventListener('change', () => {
    debouncedUpdateDividers();
    saveToLocalStorage();
  });

  // Header Settings
  [Elements.headerTextInput, Elements.hideHeaderCheckbox, Elements.headerBgColorInput,
   Elements.headerBgOpacityInput, Elements.headerTextColorInput].forEach(inp =>
    inp.addEventListener('input', () => {
      updateHeader();
      updateToolbarColors();
    })
  );

  // Обработчики цвета темы
  [Elements.color1Input, Elements.color2Input].forEach(input => {
    input.addEventListener('input', () => {
      updateToolbarColors();
      updateActionIconColors(); // Добавляем обновление цветов иконок
      saveToLocalStorage();
    });
  });
  Elements.colorIntOverInput.addEventListener('input', () => {
    saveToLocalStorage();
  });

  // Loader
  [Elements.hideLoaderCheckbox, Elements.loaderBgColorInput, Elements.loaderOpacityInput].forEach(input => {
    input.addEventListener('input', () => {
      updateLoader();
      saveToLocalStorage();
    });
  });

  // Toolbar Visibility
  Elements.hideHeaderCheckbox.addEventListener('change', () => {
    updateToolbarVisibility();
    Elements.mainHeader.classList.toggle('hidden', Elements.hideHeaderCheckbox.checked);
  });

  // Слушатель события нажатия на кнопку применить измененния
  Elements.applyChangesBtn.onclick = () => {
    saveToLocalStorage(); // Сохраняем настройки
    renderCameras(); // ОСновляем нашу страницу
    location.reload(); // Перезагружаем страницу
  };

  // Refresh Cameras
  Elements.refreshCamerasBtn.onclick = () => {
    // 1. Развернуть все свернутые уведомления
    const allNotifications = document.querySelectorAll(".notification");
    allNotifications.forEach(notification => {
      if (notification.dataset.collapsed === 'true') {
        // Удаляем состояние свёрнутости
        delete notification.dataset.collapsed;
        notification.classList.remove('collapsed');
      }
    });

    // 2. Скрыть панель действий уведомлений
    const notificationActions = document.getElementById('notificationActions');
    if (notificationActions) {
        notificationActions.classList.add('hidden');
    }

    // Дополнительно обновить позиции уведомлений (по желанию)
    schedulePositionUpdate();

    // Перерисовка камер (если это часть refreshCamerasBtn)
    renderCameras();
    debouncedUpdateDividers();
    syncDividerStyles();
  };

  function updateCameraTableOrder() {
    const cameraElements = document.querySelectorAll('.camera-box');
    const newOrder = [];
    
    cameraElements.forEach(el => {
      const ip = el.dataset.ip;
      const existingCamera = cameras.find(cam => cam.ip === ip);
      if (existingCamera) {
        newOrder.push(existingCamera);
      }
    });
    
    cameras = newOrder;
  }

  // Save Position
  Elements.savePositionBtn.onclick = () => {
    updateCameraTableOrder();
    saveToLocalStorage();
    enqueueNotification("Положение камер сохранено", "system");
  };

  // Notifications
  [Elements.errorNotificationColorInput, Elements.notificationOpacityInput].forEach(inp => {
    inp.addEventListener('input', saveToLocalStorage);
  });

  // Fullscreen
  document.addEventListener('fullscreenchange', () => {
    document.querySelectorAll('.camera-box.fullscreen').forEach(el => {
      el.classList.remove('fullscreen');
    });
  });
}

// === HEADER ===
function updateHeader() {
  document.documentElement.style.setProperty('--toolbar-icon-color', Elements.headerTextColorInput.value);
  Elements.headerTitle.textContent = Elements.headerTextInput.value.trim() || 'Активные принтера';

  if (Elements.hideHeaderCheckbox.checked) {
    Elements.mainHeader.classList.add('hidden');
  } else {
    Elements.mainHeader.classList.remove('hidden');
  }

  Elements.headerTitle.style.color = Elements.headerTextColorInput.value;

  const bg = Elements.headerBgColorInput.value;
  const op = parseFloat(Elements.headerBgOpacityInput.value);
  Elements.headerBar.style.backgroundColor = `rgba(${parseInt(bg.substr(1,2),16)},${parseInt(bg.substr(3,2),16)},${parseInt(bg.substr(5,2),16)},${op})`;
}

// === GRID SETTINGS ===
function updateGrid() {
  Elements.cameraContainer.style.gridTemplateColumns = `repeat(${Elements.gridColumnsInput.value}, minmax(0, 1fr))`;
  updateAntsVisibility();
}

// === INTERFACE WIDTH ===
function updateInterfaceWidth() {
    const width = +Elements.interfaceWidthInput.value;
    const screenWidth = window.innerWidth;
    const padding = 20; // отступы слева и справа

    // Ограничиваем ширину максимум до ширины экрана минус отступы
    const finalWidth = Math.min(Math.max(width, 800), screenWidth - padding);

    // Синхронизируем ползунок и инпут
    Elements.interfaceWidthInput.value = finalWidth;
    Elements.interfaceWidth.value = finalWidth;

    // Применяем ширину
    [Elements.mainInterfaceContainer, Elements.mainInterfaceContainerCameras].forEach(el => {
        el.style.width = `${finalWidth}px`;
        el.style.maxWidth = `${finalWidth}px`;
        // Центрируем только если она меньше экрана
        if (finalWidth < screenWidth) {
            el.style.marginLeft = 'auto';
            el.style.marginRight = 'auto';
        } else {
            el.style.marginLeft = `${padding / 2}px`;
            el.style.marginRight = `${padding / 2}px`;
        }
    });

    Elements.interfaceWidthValue.textContent = 'px';
    saveToLocalStorage();
    debouncedUpdateDividers();
}
// Добавим обработчик изменения размера окна
window.addEventListener('resize', debounce(() => {
    updateInterfaceWidth();
}, 100));

// Обработчики событий для обоих инпутов
Elements.interfaceWidth.addEventListener('input', e => {
    const value = Math.min(Math.max(parseInt(e.target.value), 800), window.innerWidth - 20);
    if (!isNaN(value)) {
        Elements.interfaceWidthInput.value = value;
        debouncedUpdateInterfaceWidth();
    }
})
Elements.interfaceWidthInput.addEventListener('input', e => {
    const value = Math.min(Math.max(parseInt(e.target.value), 800), window.innerWidth - 20);
    if (!isNaN(value)) {
        Elements.interfaceWidth.value = value;
        debouncedUpdateInterfaceWidth();
        updateInterfaceWidth();
        saveToLocalStorage();
    }
});

function setDefaultInterfaceWidth() {
    const defaultWidth = 1400;
    Elements.interfaceWidth.value = defaultWidth;
    Elements.interfaceWidthInput.value = defaultWidth;
    updateInterfaceWidth();
}





// === CAMERA TABLE ===

// ==== Локальный State ====
let cameras = []; // глобальный массив

function loadCameras(initialCameras) {
  cameras = initialCameras.map(({ip, stream, name}) => ({
    ip,
    stream: typeof stream === 'string' ? stream : '',
    name: typeof name === 'string' ? name : ''
  }));
  renderCameraTable();
}
// Добавление камеры
function addCamera() {
  cameras.push({ip: '', name: ''});
  renderCameraTable();
  saveToLocalStorage();
  renderCameras();
}
// Добавление dammy
function addDammy() {
  cameras.push({ip: 'dammy', name: ''});
  renderCameraTable();
  saveToLocalStorage();
  renderCameras();
}

// Редактирование поля
function onInputChange(rowIdx, field, value) {
  cameras[rowIdx][field] = value;
  saveToLocalStorage();
}

// Удаление строки
function deleteRow(idx) {
  cameras.splice(idx, 1);
  renderCameraTable();
  saveToLocalStorage();
  renderCameras();
}



// Drag-and-drop: после перемещения строк
function reorderRows(newOrderArray) {
  cameras = newOrderArray;
  renderCameraTable();
  saveToLocalStorage();
  renderCameras();
}
// ==== Модальное окно ====
const lockBody = l => document.documentElement.classList.toggle('overflow-hidden', l);
const toggleIcon = o => {
  Elements.openBtn.querySelector('.icon-gear').classList.toggle('hidden', o);
  Elements.openBtn.querySelector('.icon-close').classList.toggle('hidden', !o);
  Elements.openBtn.setAttribute('aria-label', o ? 'Закрыть' : 'Настройки');
};
function animateHeight(fn,el) {
  const s = el.offsetHeight;
  fn();
  requestAnimationFrame(() => {
    const e = el.offsetHeight;
    el.style.height = s + 'px';
    el.offsetHeight;
    el.style.transition = 'height .3s ease';
    el.style.height = e + 'px';
    el.addEventListener('transitionend',() => {
      el.style.height = '';
      el.style.transition = '';
    },{once:true});
  });
}
// --- Исправленное поведение openSettingsBtnModal и settingsModal ---

// Получаем элементы
const openBtn = Elements.openBtn; // Кнопка "шестеренка" (openSettingsBtnModal)
const modal = Elements.modal; // <div id="settingsModal">
const modalHolder = Elements.modalHolder; // Куда телепортируем mainSectionWrap
const mainWrap = Elements.mainWrap; // <div id="mainSectionWrap">
const accordionList = Elements.accordionList;

// Селекторы для элементов, участвующих в изменении
const customCheckboxContainer = () => mainWrap.querySelector('.custom-checkbox-container');
const buttonAccordionCameras = () => mainWrap.querySelector('.accordion-toggle');
const iconClose = () => openBtn.querySelector('.icon-close');

// Сохранение изначальных стилей для восстановления
let _originalCheckboxOpacity = null;
let _originalButtonAccordionPointerEvents = null;
let _originalOpenBtnRight = null;
let _originalIconCloseTransform = null;
let _originalTableWrapperDisplay = null;
let _originalTableWrapperFlexDirection = null;
let _originalScrollableTableFlex = null;
let _originalScrollableTableHeight = null;
let _originalScrollableTableMaxHeight = null;
let _originalScrollableTableMinHeight = null;
let _originalScrollableTableOverflow = null;
let _originalAccordionContentFlex = null;
let _originalAccordionContentHeight = null;
let _originalAccordionContentMaxHeight = null;
let _originalAccordionContentMinHeight = null;
let _originalAccordionContentOverflow = null;
// Внутреннее состояние
let isSettingsModalOpen = false;

// Получаем элементы для ограничения достука кнопки открытия модального окна
const mainSectionWrap = document.getElementById('mainSectionWrap');
const openSettingsBtnModal = document.getElementById('openSettingsBtnModal');

// Функция обновления состояния кнопки
function updateOpenSettingsButtonState() {
    if (!mainSectionWrap || !openSettingsBtnModal) return;

    if (mainSectionWrap.classList.contains('accordion-open')) {
        // Разрешить нажатие
        openSettingsBtnModal.removeAttribute('disabled');
        openSettingsBtnModal.style.opacity = '1';
        openSettingsBtnModal.style.pointerEvents = 'auto';
    } else {
        // Запретить нажатие
        openSettingsBtnModal.setAttribute('disabled', 'disabled');
        openSettingsBtnModal.style.opacity = '0';
        openSettingsBtnModal.style.pointerEvents = 'none';
    }
}

// Наблюдатель за изменениями классов mainSectionWrap
const observer = new MutationObserver(() => {
    updateOpenSettingsButtonState();
});

if (mainSectionWrap) {
    observer.observe(mainSectionWrap, { attributes: true, attributeFilter: ['class'] });
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    updateOpenSettingsButtonState();
});
/**
 * Открыть модальное окно с телепортацией mainSectionWrap внутрь modalHolder
 * и поднятием settingsModal над settingsPanel
 */
function openModalSet() {
  // Скрываем mainWrap из settingsPanel, телепортируем в modalHolder
  modalHolder.appendChild(mainWrap);
  mainWrap.classList.add('modal-expanded');
  // Показываем модальное окно
  modal.classList.remove('hidden');
  modal.style.zIndex = '1000';
  // settingsPanel на задний план
  settingsPanel.style.zIndex = '900';
  // Обновляем иконки
  openBtn.querySelector('.icon-gear').classList.add('hidden');
  openBtn.querySelector('.icon-close').classList.remove('hidden');
  openBtn.setAttribute('aria-label', 'Закрыть');
  isSettingsModalOpen = true;
  document.documentElement.classList.add('overflow-hidden');
  lucide.createIcons && lucide.createIcons();
  unlockTableHeight();

  // 1. Прозрачность custom-checkbox-container
  const checkboxCont = customCheckboxContainer();
  if (checkboxCont) {
    if (_originalCheckboxOpacity === null) _originalCheckboxOpacity = checkboxCont.style.opacity || '';
    checkboxCont.style.opacity = '0.25';
    checkboxCont.style.pointerEvents = 'none';
    checkboxCont.style.transition = 'opacity 0.4s';
  }

  // 2. Деактивация кнопки-аккордеона (accordion-toggle)
  const btnAccordion = buttonAccordionCameras();
  if (btnAccordion) {
    if (_originalButtonAccordionPointerEvents === null) _originalButtonAccordionPointerEvents = btnAccordion.style.pointerEvents || '';
    btnAccordion.style.pointerEvents = 'none';
    btnAccordion.style.opacity = '0.95';
    btnAccordion.style.cursor = 'not-allowed';
    btnAccordion.style.transition = 'opacity 0.4s';
  }

  // 3. Кнопка openSettingsBtnModal (icon-close) увеличивается и перемещается направо
  const icon = iconClose();
  if (icon) {
    if (_originalIconCloseTransform === null) _originalIconCloseTransform = icon.style.transform || '';
    icon.style.transform = 'scale(2)';
    icon.style.transition = 'transform 0.4s';
  }
  if (_originalOpenBtnRight === null) _originalOpenBtnRight = openBtn.style.right || '';
  openBtn.style.right = '24px'; // Было 56px

}

/**
 * Закрыть модальное окно, вернуть mainSectionWrap обратно в settingsPanel
 * и скрыть settingsModal
 */
function closeModalSet() {
  // Возвращаем mainWrap обратно внутрь settingsPanel (в конец)
  accordionList.appendChild(mainWrap);
  mainWrap.classList.remove('modal-expanded');
  // Прячем модальное окно
  modal.classList.add('hidden');
  modal.style.zIndex = '';
  // settingsPanel снова на передний план
  settingsPanel.style.zIndex = '';
  // Обновляем иконки
  openBtn.querySelector('.icon-gear').classList.remove('hidden');
  openBtn.querySelector('.icon-close').classList.add('hidden');
  openBtn.setAttribute('aria-label', 'Настройки');
  isSettingsModalOpen = false;
  document.documentElement.classList.remove('overflow-hidden');
  restoreTableHeight();

  // 1. Восстанавливаем custom-checkbox-container
  const checkboxCont = customCheckboxContainer();
  if (checkboxCont && _originalCheckboxOpacity !== null) {
    checkboxCont.style.opacity = _originalCheckboxOpacity;
    checkboxCont.style.pointerEvents = '';
  }

  // 2. Восстанавливаем pointer-events и opacity accordion-toggle
  const btnAccordion = buttonAccordionCameras();
  if (btnAccordion && _originalButtonAccordionPointerEvents !== null) {
    btnAccordion.style.pointerEvents = _originalButtonAccordionPointerEvents;
    btnAccordion.style.opacity = '';
    btnAccordion.style.cursor = '';
  }

  // 3. Восстанавливаем scale icon-close и right openBtn
  const icon = iconClose();
  if (icon && _originalIconCloseTransform !== null) {
    icon.style.transform = _originalIconCloseTransform;
  }
  if (_originalOpenBtnRight !== null) openBtn.style.right = _originalOpenBtnRight;
}

function unlockTableHeight() {
  // tableWrapper — делаем flex column
  const tw = mainWrap.querySelector('#tableWrapper');
  if (tw) {
    if (_originalTableWrapperDisplay === null) _originalTableWrapperDisplay = tw.style.display || '';
    if (_originalTableWrapperFlexDirection === null) _originalTableWrapperFlexDirection = tw.style.flexDirection || '';
    tw.style.display = 'flex';
    tw.style.flexDirection = 'column';
  }

  // scrollable-table — растягиваем на всю высоту
  const st = mainWrap.querySelector('.scrollable-table');
  if (st) {
    if (_originalScrollableTableFlex === null) _originalScrollableTableFlex = st.style.flex || '';
    if (_originalScrollableTableHeight === null) _originalScrollableTableHeight = st.style.height || '';
    if (_originalScrollableTableMaxHeight === null) _originalScrollableTableMaxHeight = st.style.maxHeight || '';
    if (_originalScrollableTableMinHeight === null) _originalScrollableTableMinHeight = st.style.minHeight || '';
    if (_originalScrollableTableOverflow === null) _originalScrollableTableOverflow = st.style.overflow || '';
    st.style.flex = '1 1 0%';
    st.style.height = 'auto';
    st.style.maxHeight = 'none';
    st.style.minHeight = '0';
    st.style.overflow = 'auto';
  }

  // accordion-content[data-accordion-content="cameras"] — тоже растягиваем (если надо)
  const ac = mainWrap.querySelector('.accordion-content[data-accordion-content="cameras"]');
  if (ac) {
    if (_originalAccordionContentFlex === null) _originalAccordionContentFlex = ac.style.flex || '';
    if (_originalAccordionContentHeight === null) _originalAccordionContentHeight = ac.style.height || '';
    if (_originalAccordionContentMaxHeight === null) _originalAccordionContentMaxHeight = ac.style.maxHeight || '';
    if (_originalAccordionContentMinHeight === null) _originalAccordionContentMinHeight = ac.style.minHeight || '';
    if (_originalAccordionContentOverflow === null) _originalAccordionContentOverflow = ac.style.overflow || '';
    ac.style.flex = '1 1 0%';
    ac.style.height = 'auto';
    ac.style.maxHeight = 'none';
    ac.style.minHeight = '0';
    ac.style.overflow = 'auto';
  }

  // mainButtons — ничего не меняем, он останется внизу благодаря flex
}

function restoreTableHeight() {
  // tableWrapper
  const tw = mainWrap.querySelector('#tableWrapper');
  if (tw) {
    if (_originalTableWrapperDisplay !== null) tw.style.display = _originalTableWrapperDisplay;
    if (_originalTableWrapperFlexDirection !== null) tw.style.flexDirection = _originalTableWrapperFlexDirection;
  }

  // scrollable-table
  const st = mainWrap.querySelector('.scrollable-table');
  if (st) {
    if (_originalScrollableTableFlex !== null) st.style.flex = _originalScrollableTableFlex;
    if (_originalScrollableTableHeight !== null) st.style.height = _originalScrollableTableHeight;
    if (_originalScrollableTableMaxHeight !== null) st.style.maxHeight = _originalScrollableTableMaxHeight;
    if (_originalScrollableTableMinHeight !== null) st.style.minHeight = _originalScrollableTableMinHeight;
    if (_originalScrollableTableOverflow !== null) st.style.overflow = _originalScrollableTableOverflow;
  }

  // accordion-content
  const ac = mainWrap.querySelector('.accordion-content[data-accordion-content="cameras"]');
  if (ac) {
    if (_originalAccordionContentFlex !== null) ac.style.flex = _originalAccordionContentFlex;
    if (_originalAccordionContentHeight !== null) ac.style.height = _originalAccordionContentHeight;
    if (_originalAccordionContentMaxHeight !== null) ac.style.maxHeight = _originalAccordionContentMaxHeight;
    if (_originalAccordionContentMinHeight !== null) ac.style.minHeight = _originalAccordionContentMinHeight;
    if (_originalAccordionContentOverflow !== null) ac.style.overflow = _originalAccordionContentOverflow;
  }
}

openBtn.addEventListener('click', () => {
  if (!isSettingsModalOpen) {
    openModalSet();
  } else {
    closeModalSet();
  }
});

// Клик вне mainWrap закрывает модалку
modal.addEventListener('click', e => {
  if (e.target === modal) closeModalSet();
});

// Escape закрывает модалку
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && isSettingsModalOpen) closeModalSet();
});

// Гарантируем что при инициализации mainWrap внутри settingsPanel
if (!settingsPanel.contains(mainWrap)) {
  settingsPanel.appendChild(mainWrap);
  mainWrap.classList.remove('modal-expanded');
}
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && !Elements.modal.classList.contains('hidden')) closeModalSet()
});



// ==== Генерация HTML строки ====
function rowHTML(isDammy, ip = '', stream = '', name = ''){
  if(isDammy) return `
    <td class="p-2 text-center handle cursor-grab"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="grip-vertical" class="lucide lucide-grip-vertical w-4 h-4"><circle cx="9" cy="12" r="1"></circle><circle cx="9" cy="5" r="1"></circle><circle cx="9" cy="19" r="1"></circle><circle cx="15" cy="12" r="1"></circle><circle cx="15" cy="5" r="1"></circle><circle cx="15" cy="19" r="1"></circle></svg></td>
    <td colspan="2" class="p-2"><input disabled class="dynamic-input w-full rounded-xl px-3 py-2 text-center" value="— Пустой слот —"></td>
    <td class="p-2 border-l border-[rgb(var(--white)/0.1)]"><input disabled class="dynamic-input w-full rounded-xl px-3 py-2 text-center"></td>
    <td class="p-2 text-center animate-pulse-slow"><button class="remove-camera-btn rounded-xl p-2 htext-[rgb(var(--stickyHeader-rgb))] hover:text-[rgb(var(--tetrad1-light-rgb))] transition active:scale-90" aria-label="Удалить">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="trash-2" class="lucide lucide-trash-2 w-4 h-4"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg></button></td>`;
  return `
    <td class="p-2 text-center handle cursor-grab"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="grip-vertical" class="lucide lucide-grip-vertical w-4 h-4"><circle cx="9" cy="12" r="1"></circle><circle cx="9" cy="5" r="1"></circle><circle cx="9" cy="19" r="1"></circle><circle cx="15" cy="12" r="1"></circle><circle cx="15" cy="5" r="1"></circle><circle cx="15" cy="19" r="1"></circle></svg></td>
    <td class="ip-cell p-2 text-right"><input maxlength="22" class="dynamic-input w-[15ch] rounded-xl bg-transparent px-3 py-2 text-right" type="text" value="${ip||''}" placeholder="IP / URL"></td>
    <td class="p-2"><div class="relative group"><input class="peer dynamic-input stream-input w-full rounded-xl bg-transparent px-3 py-2 pr-10" type="text" value="${stream||''}" placeholder=":8080/?action=stream"><button type="button" class="stream-toggle absolute right-2 top-1/2 -translate-y-1/2 p-1 rounded-lg bg-[rgb(var(--tetrad1-light-rgb)/0.1)] text-[rgb(var(--stickyHeader-rgb))] hover:bg-[rgb(var(--tetrad2-dark-rgb)/0.8)] hover:text-[rgb(var(--white))] transition opacity-0 pointer-events-none peer-focus:opacity-100 peer-focus:pointer-events-auto group-hover:opacity-100 group-hover:pointer-events-auto" aria-label="Переключить stream"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="shuffle" class="lucide lucide-shuffle w-4 h-4"><path d="m18 14 4 4-4 4"></path><path d="m18 2 4 4-4 4"></path><path d="M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22"></path><path d="M2 6h1.972a4 4 0 0 1 3.6 2.2"></path><path d="M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45"></path></svg></button></div></td>
    <td class="p-2 border-l border-[rgb(var(--white)/0.1)]"><input class="dynamic-input w-full rounded-xl bg-transparent px-3 py-2" type="text" value="${name||''}" placeholder="Название"></td>
    <td class="p-2 text-center"><button class="remove-camera-btn rounded-xl p-2 text-[rgb(var(--stickyHeader-rgb))] hover:text-[rgb(var(--tetrad1-light-rgb))] transition active:scale-90" aria-label="Удалить"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="trash-2" class="lucide lucide-trash-2 w-4 h-4"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg></button></td>`;
}

// ==== Добавление строки ====
// Слушатель событий. При нажатии на кнопку запускам addRow
Elements.addCameraBtn.onclick = () => {
  animateHeight(() => {
    addRow(false);
  }, Elements.tableWrapper);
};

Elements.addDammyCameraBtn.onclick = () => animateHeight(() => addRow(true), Elements.tableWrapper);
// При нажатии на кнопку проверяем ключь и записываем переменные
function addRow(isDammy){
  cameras.push(isDammy ? {ip:'dammy', stream: '' ,name:''} : {ip:'', stream:'' ,name:''});
  renderCameraTable();
}
// получаем массив
function renderCameraTable(camArr = cameras) {
  Elements.tbody.innerHTML = '';
  camArr.forEach(({ ip, name, stream }, idx) => {
    const tr = document.createElement('tr');
    tr.className = 'group animate-row-in3d' + (ip === 'dammy' ? ' dammy-slot' : '');
    tr.innerHTML = rowHTML(ip === 'dammy', ip, stream, name);

    lucide.createIcons();
    enableDrag(tr);
    initInputs(tr.querySelectorAll('.dynamic-input'));
    initStreamToggle(tr.querySelector('.stream-toggle'));

    Elements.tbody.appendChild(tr);
  });
}

// ==== Удаление строки ====
Elements.tbody.addEventListener('click', e => {
  const btn = e.target.closest('.remove-camera-btn');
  if (!btn) return;
  const row = btn.closest('tr');
  const idx = [...Elements.tbody.children].indexOf(row);
  row.classList.add('animate-row-out');
  row.addEventListener('animationend', () => {
    animateHeight(() => {
      cameras.splice(idx,1);
      renderCameraTable();
    }, Elements.tableWrapper);
  }, {once:true});
});

// ==== Drag & Drop ====
function enableDrag(row){
  const h = row.querySelector('.handle');
  if (!h) return;
  h.draggable = true;
  h.addEventListener('dragstart', e => {
    row.classList.add('draggingSet');
    Elements.indicator.style.opacity = '1';
    Elements.indicator.style.transform = 'scaleX(1)';
    const img = new Image();
    img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAE0lEQVR42mP8/5+hHgAHggJ/lBcMtQAAAABJRU5ErkJggg==';
    e.dataTransfer.setDragImage(img, 0, 0);
  });
  h.addEventListener('dragend', () => {
    row.classList.remove('draggingSet');
    Elements.indicator.style.opacity = '0';
    Elements.indicator.style.transform = 'scaleX(.6)';
  });
}
function recordPos() {
  const m=new Map();Elements.tbody.querySelectorAll('tr').forEach(r => m.set(r, r.getBoundingClientRect().top));
  return m;
}
function playFLIP(prev){
  Elements.tbody.querySelectorAll('tr').forEach(r => {
    const dy = prev.get(r) - r.getBoundingClientRect().top;
    if (dy) {
      r.style.transform = `translateY(${dy}px)`;
      r.style.transition = 'transform .3s cubic-bezier(.4,0,.2,1)';
      requestAnimationFrame(() => r.style.transform = '');
      r.addEventListener('transitionend',() => r.style.transition = '', {once:true});
      }
  });
}
Elements.tbody.addEventListener('dragover', e => {
  e.preventDefault();
  const draggingSet = Elements.tbody.querySelector('.draggingSet');
  if (!draggingSet) return;
  const rows = [...Elements.tbody.querySelectorAll('tr:not(.draggingSet)')];
  const target = rows.find(r => e.clientY <= r.getBoundingClientRect().top + r.offsetHeight / 2);
  const base = Elements.tableWrapper.getBoundingClientRect().top;
  Elements.indicator.style.top = (target ? target.getBoundingClientRect().top : (rows.pop() || draggingSet).getBoundingClientRect().bottom) - base + 'px';
});
Elements.tbody.addEventListener('drop', e => {
  e.preventDefault();
  const draggingSet = Elements.tbody.querySelector('.draggingSet');
  if (!draggingSet) return;
  const prev = recordPos();
  const rows = [...Elements.tbody.querySelectorAll('tr:not(.draggingSet)')];
  const target = rows.find(r => e.clientY <= r.getBoundingClientRect().top + r.offsetHeight / 2);
  const draggingIdx = [...Elements.tbody.children].indexOf(draggingSet);
  const targetIdx = target ? [...Elements.tbody.children].indexOf(target) : cameras.length-1;
  // Перемещаем в массиве cameras
  const cam = cameras.splice(draggingIdx,1)[0];
  cameras.splice(targetIdx,0,cam);
  renderCameraTable();
  playFLIP(prev);
  Elements.indicator.style.opacity = '0';
  Elements.indicator.style.transform = 'scaleX(.6)';
});

// ==== Inputs ====
function updateEmpty(i) {
  const td = i.closest('.ip-cell');
  if(td)td.classList.toggle('is-empty', !i.value.trim());
}
function convertToDammy(row) {
  const idx = [...Elements.tbody.children].indexOf(row);
  cameras[idx] = { ip: 'dammy', stream:'' , name: '' };
  renderCameraTable();
}
function initInputs(list) {
  list.forEach(i => {
    updateEmpty(i);
    i.addEventListener('focus', e => {
      const r = e.target.getBoundingClientRect();
      i.style.setProperty('--ix', ((e.clientX - r.left) / r.width * 100).toFixed(0) + '%'); 
      i.style.setProperty('--iy', ((e.clientY - r.top) / r.height * 100).toFixed(0) + '%');
      i.classList.add('is-focused');
    });
    i.addEventListener('blur', () => i.classList.remove('is-focused'));
    i.addEventListener('input', () => {
      updateEmpty(i);
      if (i.closest('.ip-cell') && i.value.trim().toLowerCase() === 'dammy'){
        animateHeight(() => convertToDammy(i.closest('tr')),Elements.tableWrapper);
      } else {
        // обновить cameras при изменении
        const row = i.closest('tr');
        const idx = [...Elements.tbody.children].indexOf(row);
        if (row && cameras[idx]) {
          if (i.classList.contains('stream-input')) cameras[idx].stream = i.value.trim();
          else if (i.closest('.ip-cell')) cameras[idx].ip = i.value.trim();
          else cameras[idx].name = i.value.trim();
        }
      }
    });
  });
}
initInputs(document.querySelectorAll('.dynamic-input'));

// ==== Stream toggle ====
function initStreamToggle(btn) {
  if (!btn) return;
  const input = btn.previousElementSibling;
  const ORIGINAL = ':8080/?action=stream';
  const ALT = ':8080/stream';
  btn.addEventListener('click',() => {
    const c = input.value.trim();
    input.value = !c || c.endsWith(ALT) ? ORIGINAL : ALT;
    input.focus();
    const event = new Event('input', { bubbles: true });
    input.dispatchEvent(event);
  });
}
document.querySelectorAll('.stream-toggle').forEach(initStreamToggle);

// ==== Сбор данных из таблицы ====
function getCameraTableData() {
  // Возвращает актуальный cameras (ip и name)
  return cameras.map((c, index) => ({
    ip: c.ip,
    stream: c.stream,
    name: c.name,
    order: index
  }));
}

// ==== Инициализация ====
function loadCameras(initialCameras) {
  cameras = initialCameras.map(({ip, name, stream}) => ({
    ip,
    name,
    stream: typeof stream === 'string' ? stream : ''
  }));
  renderCameraTable();
}
  let isModalOpen = false;
  function closeModal() {
    Elements.resetConfirmModal.classList.add('hidden');
    const modal = document.getElementById('cameraSettingsModal');
    if (!modal) return;
    document.body.focus();
    const focusableElements = modal.querySelectorAll('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
    focusableElements.forEach(el => el.blur());
    modal.classList.add('invisible', 'opacity-0');
    modal.setAttribute('aria-hidden', 'true');
    const contentDiv = modal.querySelector('.flex-1');
    if (contentDiv) contentDiv.innerHTML = '';
    isModalOpen = false;
  }
// === RENDER CAMERAS ===
const namedDrivInput = document.getElementById('namedDriv');
const namedDrivValueDisplay = document.getElementById('namedDrivValue');

// Функция обновления размера шрифта
function updateCameraTitleFontSize() {
  const fontSize = namedDrivInput.value;
  document.querySelectorAll('.camera-box .camera-title').forEach(title => {
    title.style.fontSize = `${fontSize}rem`;
  });
  namedDrivValueDisplay.textContent = `${fontSize}rem`;
  document.documentElement.style.setProperty('--named-driv-font-size', `${fontSize}rem`);
}

// Обработчик изменения ползунка
namedDrivInput.addEventListener('input', () => {
  updateCameraTitleFontSize();
});

// === Функция обновления статуса индикатора ===
function updateStatusIndicator(dotElement, status) {
  dotElement.classList.remove('initial', 'warning', 'disconnected', 'connect');
  switch(status) {
    case 'connect':
      dotElement.classList.add('connect');
      dotElement.title = 'Онлайн';
      break;
    case 'warning':
      dotElement.classList.add('warning');
      dotElement.title = 'Ошибка видеопотока';
      break;
    case 'error':
    case 'disconnected':
      dotElement.classList.add('disconnected');
      dotElement.title = 'Оффлайн';
      break;
    case 'initial':
    default:
      dotElement.classList.add('initial');
      dotElement.title = 'Ожидание подключения';
  }
}

/**
 * Функция для отрисовки карточек камер с поддержкой drag-and-drop, полноэкранного режима, модального окна и параллакса.
 * Повторяющийся функционал вынесен в отдельные функции, структура кода логически разбита на блоки.
 */
function renderCameras() {
  // === Инициализация и сортировка ===
  Elements.cameraContainer.innerHTML = '';
  const cameras = getCameraTableData();
  const savedSettings = JSON.parse(localStorage.getItem('printerCamsV2'));
  let orderedCameras = [...cameras];

  if (savedSettings && savedSettings.cameraOrder) {
    const orderMap = {};
    savedSettings.cameraOrder.forEach((cam, index) => { orderMap[cam.ip] = index; });
    orderedCameras.sort((a, b) => (orderMap[a.ip] ?? Infinity) - (orderMap[b.ip] ?? Infinity));
  }

  let loadedCount = 0;
  const totalCameras = cameras.length;

  if (totalCameras === 0) {
    hideLoader();
    return;
  }

  // === Вспомогательные функции для генерации данных карточки ===
  function stripPort(ip) {
    return (ip || '').split(':')[0];
  }
  function stripIpFromStream(stream) {
    if (!stream) return '';
    if (stream.startsWith(':')) return stream;
    const idx = stream.indexOf(':');
    if (idx !== -1) return stream.slice(idx);
    return stream;
  }
  function getStreamUrl(ip, stream) {
    const ipWithoutPort = stripPort(ip || '');
    const streamPart = stripIpFromStream(stream || '');
    return `http://${ipWithoutPort}${streamPart}`;
  }

  // === Функции для парраллакса и анимаций карточек ===
  function handleMouseEnter(camDiv, cam, e) {
    if (!camDiv._parallaxEnabled || cam.ip === 'dammy') return;
    const rect = camDiv.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const xc = (x / rect.width) - 0.5;
    const yc = (y / rect.height) - 0.5;
    camDiv.style.transition = 'transform .15s cubic-bezier(.42,1.8,.2,1)';
    camDiv.style.transform = `
      perspective(600px) 
      rotateY(${xc * 20}deg) 
      rotateX(${yc * -16}deg) 
      scale(1.08)
    `;
    const img = camDiv.querySelector('.camera-img img');
    if (img) {
      img.style.transform = `
        scale(1.15) 
        translate(${xc * 22}px, ${yc * 18}px) 
        rotateZ(${xc * yc * 9}deg)
      `;
    }
  }
  function handleMouseLeave(camDiv, cam) {
    if (cam.ip === 'dammy') return;
    camDiv.style.transition = 'transform .38s cubic-bezier(.4,0,.2,1)';
    camDiv.style.transform = 'perspective(500px) scale(1) rotateY(0deg) rotateX(0deg)';
    const img = camDiv.querySelector('.camera-img img');
    if (img) {
      img.style.transition = 'transform .44s cubic-bezier(.42,1.8,.2,1)';
      img.style.transform = 'scale(1)';
    }
  }

  // === Работа с полноэкранным режимом ===
  let currentFullscreenCamera = null;
  let isFullscreen = false;
  document.removeEventListener('fullscreenchange', syncFullscreenFlag); // remove old listeners if re-rendered
  function syncFullscreenFlag() {
    isFullscreen = !!document.fullscreenElement;
    if (!isFullscreen && currentFullscreenCamera) {
      currentFullscreenCamera.classList.remove('fullscreen');
      currentFullscreenCamera = null;
    }
  }
  document.addEventListener('fullscreenchange', syncFullscreenFlag);

  function enterFullscreen(cameraElement) {
    if (!cameraElement) {
      console.warn("Нет элемента для полноэкранного режима");
      return;
    }
    cameraElement.classList.add('fullscreen');
    cameraElement.requestFullscreen()
      .then(() => {
        isFullscreen = true;
        currentFullscreenCamera = cameraElement;
      })
      .catch(err => {
        console.error('Ошибка полноэкранного режима:', err);
        enqueueNotification("Не удалось войти в полноэкранный режим", "error");
      });
  }

  // === Работа с модальным окном ===

  // === Глобальные переменные для управления видеопотоками ===
  let videoStreams = new Map(); // Хранит оригинальные src для восстановления

  // === Модифицированная функция открытия модального окна ===
  function openModal(camera) {
    // 1. Останавливаем все видеопотоки
    stopAllVideoStreams();
    
    const modal = document.getElementById('cameraSettingsModal');
    if (!modal) return;
    
    modal.classList.remove('invisible', 'opacity-0');
    modal.setAttribute('aria-hidden', 'false');
    
    // Вставка контента (iframe)
    const contentDiv = modal.querySelector('.flex-1');
    let ip = '';
    
    if (camera) {
      const camName = camera.dataset.name || '';
      const rows = Elements.tbody.querySelectorAll('tr:not(.dammy-slot)');
      for (let tr of rows) {
        const ipInput = tr.querySelector('.ip-cell input');
        const nameInput = tr.querySelector('td input:not(.ip-cell input):not(.stream-input)');
        if (ipInput && nameInput && nameInput.value === camName) {
          ip = ipInput.value.trim();
          break;
        }
      }
      if (!ip) ip = camera.dataset.ip || '';
    }
    
    contentDiv.innerHTML = '';
    if (ip && ip !== 'dammy') {
      const iframe = document.createElement('iframe');
      iframe.src = `http://${ip}`;
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = 'none';
      iframe.style.background = '#222';
      iframe.allowFullscreen = true;
      iframe.referrerPolicy = "no-referrer";
      contentDiv.appendChild(iframe);
    } else {
      contentDiv.textContent = 'Неверный или отсутствует IP-адрес камеры.';
    }
    
    // Фокус на первый элемент
    const firstFocusable = modal.querySelector('button, input, [tabindex]');
    if (firstFocusable) firstFocusable.focus();
    isModalOpen = true;
    
    // Обработчики expand/manage/close внутри модала
    const expandBtn = modal.querySelector('.expand-icon');
    const manageBtn = modal.querySelector('.manage-icon');
    
    function handleExpand() { 
      closeModal(); 
      enterFullscreen(camera); 
    }
    function handleManage() { 
      closeModal(); 
      openModal(camera); 
    }
    
    if (expandBtn) {
      const newExpand = expandBtn.cloneNode(true); 
      expandBtn.replaceWith(newExpand);
      newExpand.addEventListener('click', handleExpand);
    }
    if (manageBtn) {
      const newManage = manageBtn.cloneNode(true); 
      manageBtn.replaceWith(newManage);
      newManage.addEventListener('click', handleManage);
    }
    
    // Закрытие
    const closeBtn = modal.querySelector('.manage-icon');
    const closeModalHandler = () => { closeModal(); };
    if (closeBtn) closeBtn.addEventListener('click', closeModalHandler);
    
    function escapeHandler(e) {
      if (e.key === 'Escape') {
        closeModalHandler();
        document.body.focus();
      }
    }
    document.addEventListener('keydown', escapeHandler, { once: true });
  }

  // === Функция остановки всех видеопотоков ===
  function stopAllVideoStreams() {
    if (!Elements.offFullCheckbox.checked) return;

    const allImages = document.querySelectorAll('.camera-box .camera-img img');
    
    // Очищаем предыдущие данные
    videoStreams.clear();
    pendingRestores = 0; // На старте — нет активных восстановлений

    allImages.forEach(img => {
        if (img.src && !img.src.startsWith('data:')) {
            videoStreams.set(img, img.src);
            img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            pendingRestores++;
            pendingRestores++; // Увеличиваем счётчик для КАЖДОГО остановленного потока
        }
    });

    // Включаем подавление уведомлений
    suppressNotifications = true;
  }

  // === Функция восстановления всех видеопотоков ===
  function restoreAllVideoStreams() {
    if (!Elements.offFullCheckbox.checked || pendingRestores === 0) return;

    videoStreams.forEach((originalSrc, img) => {
        const separator = originalSrc.includes('?') ? '&' : '?';
        const newSrc = originalSrc + separator + '_t=' + Date.now();

        // Создаём обработчик один раз
        const onLoad = () => {
            img.removeEventListener('load', onLoad);
            img.removeEventListener('error', onLoad);
            pendingRestores--; // Один из потоков успешно восстановлен

            // Если все потоки восстановились — снимаем блокировку
            if (pendingRestores <= 0) {
                suppressNotifications = false;
                pendingRestores = 0;
            }
        };

        img.addEventListener('load', onLoad);
        img.addEventListener('error', onLoad);

        img.src = newSrc;
    });

    videoStreams.clear();
  }

  // === Модифицированная функция закрытия модального окна ===
  function closeModal() {
    const modal = document.getElementById('cameraSettingsModal');
    if (!modal) return;

    // Восстанавливаем видеопотоки
    restoreAllVideoStreams();

    // Ждем выполнения всех действий и закрываем модалку
    setTimeout(() => {
      document.body.focus();
      const focusableElements = modal.querySelectorAll('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
      focusableElements.forEach(el => el.blur());
      
      modal.classList.add('invisible', 'opacity-0');
      modal.setAttribute('aria-hidden', 'true');
      
      const contentDiv = modal.querySelector('.flex-1');
      if (contentDiv) contentDiv.innerHTML = '';
      
      isModalOpen = false;
    }, 400); // Увеличена задержка для обработки всех действий
  }

  // === Дополнительно: обновим обработчики закрытия ===
  // Escape handler также должен использовать новую closeModal
  document.addEventListener('keydown', e => {
    if (e.key === 'Escape' && isModalOpen) {
      e.preventDefault();
      closeModal();
    }
  });

  // Обработчик клика на backdrop
  document.getElementById('cameraSettingsModal')?.addEventListener('click', e => {
    if (e.target === e.currentTarget) {
      closeModal();
    }
  });

  // === Основной цикл по камерам ===
  orderedCameras.forEach((cam, idx) => {
    const camDiv = document.createElement('div');
    camDiv.className = "camera-box group relative bg-cams rounded-xl shadow-lg flex items-stretch overflow-hidden transition hover:scale-105 cursor-grab camera-disconnected";
    //camDiv.style = "pointerEvents:none; ";
    camDiv.setAttribute('draggable', 'true');
    camDiv.dataset.ip = cam.ip;
    camDiv.dataset.name = cam.name;
    camDiv.dataset.stream = cam.stream;
    camDiv._parallaxEnabled = true;

    const isDammy = cam.ip === 'dammy';
    if (isDammy) {
      camDiv.classList.add('dammy');
      camDiv.style.opacity = '0';
      camDiv.innerHTML = `
        <div class="camera-img relative w-full h-full flex items-center justify-center min-h-[180px]">
          <div class="bottom-glass"></div>
        </div>
      `;
    } else {
      const streamUrl = getStreamUrl(cam.ip, cam.stream);
      camDiv.innerHTML = `
        <div class="camera-img relative w-full h-full flex items-center justify-center min-h-[180px]">
          <img src="${streamUrl}" 
            alt="${cam.name||'Принтер'}"
            class="w-full h-full object-cover transition group-hover:brightness-95 duration-300 absolute top-0 left-0 hidden"
            style="min-height:180px; max-height:100%; display:none; pointer-events:none;"/>
          <div class="zone-right">
            <div class="action-icon expand-icon" title="Развернуть" tabindex="0" role="button"><i class="fas fa-expand"></i></div>
            <div class="action-icon manage-icon" title="Управление" tabindex="0" role="button"><i class="fas fa-cog"></i></div>
          </div>
          <div class="bottom-glass"></div>
          <div class="status-dot initial" title="Ожидание подключения" data-ip="${cam.ip}"></div>
        <div class="camera-title">${cam.name || 'Без имени'}</div>
      `;
    }

    const img = camDiv.querySelector('img');
    const statusDot = camDiv.querySelector('.status-dot');
    const expandIcon = camDiv.querySelector('.expand-icon');
    const manageIcon = camDiv.querySelector('.manage-icon');


    // === Параллакс и эффекты ===
    const throttledParallax = throttle((e) => handleMouseEnter(camDiv, cam, e), 5);
    camDiv.addEventListener('mousemove', throttledParallax);
    camDiv.addEventListener('mouseleave', () => handleMouseLeave(camDiv, cam));
    camDiv.addEventListener('fullscreenchange', () => {
      camDiv._parallaxEnabled = !document.fullscreenElement;
    });

    // === Кнопки и эффекты на не-dammy карточках ===
    if (!isDammy) {
      // === Загрузка изображения и обработка ошибок ===
      img.onerror = () => {
        loadedCount++;
        camDiv.style.pointerEvents = 'none';
        camDiv.style.transform = 'none';
        camDiv.style.transition = 'none';
        fetch(`http://${cam.ip}`, { mode: 'no-cors' })
        .then(() => {
          camDiv.classList.remove('camera-disconnected');
          camDiv.style.pointerEvents = 'auto';

          // Оставляем параллакс и стили (НЕ ставим camera-disconnected)
          if (statusDot) {
            updateStatusIndicator(statusDot, 'warning');
          }
          if (expandIcon) {
            expandIcon.classList.add('btn-disabled');
            expandIcon.setAttribute('aria-disabled', 'true');
            expandIcon.style.pointerEvents = 'none';
            expandIcon.style.opacity = '0.6';
          }
          if (manageIcon) {
            manageIcon.classList.remove('btn-disabled');
            manageIcon.removeAttribute('aria-disabled');
            manageIcon.style.pointerEvents = '';
            manageIcon.style.opacity = '';
          }
          // Показать заглушку/ссылку вместо видео:
          let stub = camDiv.querySelector('.camera-stub');
          if (!stub) {
            stub = document.createElement('div');
            stub.className = 'camera-stub flex items-center justify-center w-full h-full font-semibold rounded-lg';
            stub.style.position = 'absolute';
            stub.style.top = 0;
            stub.style.left = 0;
            stub.style.right = 0;
            stub.style.bottom = 0;
            stub.innerHTML = `<section class="anim-border w-full">
                        <div class="flex flex-col items-center">

                          <!-- SVG Icon (сохранили) -->
                          <svg class="w-16 h-16 icon-pulse" viewBox="0 0 512 512" aria-hidden="true" focusable="false" fill="url(#bezelGrad2)">
                            <defs>
                              <linearGradient id="bezelGrad2" x1="0" y1="0" x2="1" y2="1">
                                <stop offset="0%"  stop-color="rgb(var(--base1-light-rgb))"/>
                                <stop offset="100%" stop-color="rgb(var(--base2-light-rgb))"/>
                              </linearGradient>
                            </defs>
                            <g transform="translate(0,512) scale(0.1,-0.1)" stroke="none">
                              <path d="M2810 4951 c-69 -21 -122 -66 -156 -131 -13 -25 -19 -68 -23 -153 -6 109 -8 -120 -30 -138 -13 -11 -39 -19 -58 -19 -30 0 -46 10 -107 69 -82 81 -140 111 -211 111 -80 0 -137 -34 -247 -146 -84 -87 -98 -106 -113 -158 -30 -103 -4 -178 101 -287 51 -52 64 -72 64 -96 0 -74 -32 -93 -162 -93 -77 0 -102 -4 -144 -24 -104 -48 -144 -133 -144 -302 0 -131 13 -188 55 -245 51 -70 104 -92 243 -99 104 -5 115 -7 133 -29 11 -13 19 -39 19 -58 0 -31 -11 -47 -75 -114 -61 -64 -77 -88 -91 -135 -32 -112 -2 -184 135 -317 82 -80 107 -98 151 -111 67 -20 83 -20 149 0 41 12 69 31 130 90 68 65 83 74 115 74 26 0 44 -7 61 -25 23 -22 25 -32 25 -118 0 -118 19 -176 76 -233 57 -57 115 -74 259 -74 130 0 193 16 249 62 61 50 86 115 86 226 0 129 19 162 92 162 24 0 46 -14 101 -66 84 -80 137 -106 217 -105 85 0 122 20 227 124 106 103 132 145 140 223 9 80 -16 134 -104 226 -62 65 -73 82 -73 111 0 19 9 45 19 58 18 22 29 24 138 29 106 5 124 9 166 33 100 59 126 122 126 307 1 121 -2 140 -23 186 -27 59 -90 116 -145 132 -21 7 -80 12 -130 12 -89 0 -94 1 -122 29 -48 49 -41 79 40 165 80 84 100 119 108 186 11 97 -7 132 -136 261 -129 129 -164 147 -261 136 -67 -8 -102 -28 -186 -108 -86 -81 -116 -88 -165 -40 -28 28 -29 33 -29 122 0 50 -5 109 -12 130 -16 55 -73 118 -132 145 -46 21 -64 24 -186 23 -74 0 -146 -4 -160 -8z m289 -166 c37 -19 41 -31 41 -129 0 -45 7 -105 15 -132 32 -110 135 -181 250 -172 78 7 107 22 199 108 105 97 113 96 228 -18 114 -115 115 -123 18 -228 -86 -93 -101 -121 -108 -201 -4 -54 -1 -70 22 -117 51 -104 133 -146 282 -146 45 0 90 -3 99 -6 33 -13 45 -59 45 -174 0 -110 0 -112 -29 -141 -28 -28 -33 -29 -122 -29 -123 0 -163 -13 -224 -75 -53 -53 -75 -102 -75 -170 0 -73 21 -115 102 -202 82 -89 91 -110 64 -161 -19 -37 -138 -149 -171 -162 -41 -16 -62 -5 -145 74 -82 78 -121 96 -209 96 -63 0 -115 -21 -159 -63 -60 -57 -75 -99 -81 -224 -8 -157 -10 -158 -177 -158 -125 0 -126 0 -150 28 -22 25 -24 37 -24 125 -1 53 -7 113 -14 133 -34 97 -128 161 -235 160 -78 0 -126 -25 -214 -109 -97 -94 -111 -93 -222 19 -117 116 -118 124 -25 225 88 94 109 138 110 220 0 98 -48 175 -140 224 -14 8 -75 16 -143 20 -160 8 -161 9 -165 169 -3 114 -3 118 22 148 26 30 27 31 138 35 129 4 172 20 228 84 43 50 60 93 60 155 0 88 -18 127 -97 209 -39 42 -74 87 -78 102 -10 38 13 74 99 156 104 99 116 98 229 -6 89 -83 129 -102 208 -102 53 0 133 36 171 76 50 54 68 109 68 217 0 95 1 99 29 128 29 29 31 29 141 29 78 0 119 -4 139 -15z"/>
                              <path d="M2845 4265 c-279 -52 -494 -256 -560 -532 -27 -111 -18 -271 22 -384 71 -205 231 -364 438 -435 62 -21 105 -28 193 -32 138 -6 219 11 342 71 69 34 102 58 176 132 126 126 182 238 205 410 12 97 3 131 -44 153 -53 25 -107 -13 -107 -75 -1 -59 -31 -171 -66 -242 -68 -138 -213 -251 -361 -281 -81 -17 -225 -8 -298 18 -149 54 -273 179 -327 329 -26 71 -35 216 -18 296 31 154 147 298 293 367 97 47 187 63 295 54 88 -7 117 7 128 62 16 86 -119 125 -311 89z"/>
                              <path d="M3275 4135 c-45 -44 -35 -77 48 -155 41 -39 90 -97 111 -134 21 -36 45 -71 53 -77 40 -34 123 7 123 61 0 60 -98 202 -193 282 -68 56 -104 62 -142 23z"/>
                              <path d="M4283 1804 c-61 -22 -118 -77 -285 -275 -216 -259 -259 -288 -427 -297 -87 -4 -94 -3 -87 13 64 167 2 335 -154 416 l-45 24 -601 0 -600 0 -75 -37 c-48 -25 -111 -70 -181 -133 -59 -52 -109 -95 -112 -95 -3 0 -6 29 -6 64  0 54 -4 70 -24 93 l-24 28 -579 3 c-318 2 -593 0 -611 -3 -17 -3 -41 -16 -52 -27 -20 -21 -20 -36 -20 -695 l0 -674 25 -24 24 -25 606 0 606 0 24 25 c22 21 25 33 25 96 l0 72 162 -6 c318 -13 1345 -29 1443 -22 281 18 541 111 768 272 107 76 275 244 363 363 83 111 183 274 233 380 32 68 36 83 36 160 0 73 -4 93 -28 142 -31 62 -84 116 -149 149 -56 29 -192 36 -255 13z m198 -167 c50 -33 79 -82 79 -133 0 -53 -70 -196 -164 -337 -287 -429 -646 -653 -1091 -682 -98 -7 -1114 9 -1432 22 l-163 6 0 343 0 343 163 142 c91 80 184 152 212 165 l50 24 556 0 556 0 33 -23 c96 -64 96 -204 2 -259 -27 -16 -61 -18 -295 -18 -272 0 -319 -6 -337 -40 -16 -31 -11 -79 10 -100 19 -19 33 -20 504 -20 l485 0 79 25 c132 42 194 94 390 327 94 112 184 211 199 220 42 26 122 23 164 -5z m-3343 -754 l2 -563 -290 0 -290 0 0 565 0 565 288 -2 287 -3 3 -562z m412 2 l0 -565 -125 0 -125 0 0 565 0 565 125 0 125 0 0 -565z"/>
                            </g>
                          </svg>

                          <!-- Title -->
                          <h1 class="text-xl tracking-tight font-semibold">
                            Видео-сигнал недоступен
                          </h1>

                          <!-- Description -->
                          <p class="text-center text-xs/relaxed max-w-xs">
                            Вы можете продолжить работу в интерфейсе, однако действия будут выполняться «вслепую».
                          </p>
                        </div>
                      </section>`;
            camDiv.querySelector('.camera-img').appendChild(stub);
          }
          enqueueNotification(`С принтера <b>${cam.name || cam.ip}</b> нет видеосигнала`, "error");
          if (loadedCount === totalCameras) setTimeout(hideLoader, 500);
        })
        .catch(() => {
          if (statusDot) {
            updateStatusIndicator(statusDot, 'disconnected');
          }
          camDiv.style.pointerEvents = 'none';
          camDiv.style.transform = 'none';
          camDiv.style.transition = 'none';
          camDiv.style.removeProperty('transform');
          camDiv.style.removeProperty('transition');
          enqueueNotification(`Принтер <b>${cam.name || cam.ip}</b> недоступен`, "error");
          if (loadedCount === totalCameras) setTimeout(hideLoader, 500);
        })
      };
      img.onload = () => {
        loadedCount++;
        camDiv.classList.remove('camera-disconnected');
        img.classList.remove('hidden');
        img.style.display = 'block';
        img.style.pointerEvents = 'auto';
        if (statusDot) {
            updateStatusIndicator(statusDot, 'connect');
          }
        if (expandIcon) {
          expandIcon.classList.remove('btn-disabled');
          expandIcon.removeAttribute('aria-disabled');
          expandIcon.style.pointerEvents = '';
          expandIcon.style.opacity = '';
        }
        if (manageIcon) {
          manageIcon.classList.remove('btn-disabled');
          manageIcon.removeAttribute('aria-disabled');
          manageIcon.style.pointerEvents = '';
          manageIcon.style.opacity = '';
        }
        enqueueNotification(`Принтер <b>${cam.name || cam.ip}</b> инициализирован`, "system");
        if (loadedCount === totalCameras) setTimeout(hideLoader, 500);
      };
    } else {
      // dammy: просто увеличиваем счетчик
      loadedCount++;
      if (loadedCount === totalCameras) setTimeout(hideLoader, 500);
    }



    // Появление иконок
    const icons = camDiv.querySelectorAll('.action-icon');
    icons.forEach((icon, i) => { icon.style.transitionDelay = `${i * 50}ms`; });
    // Плавное появление зоны справа
    const rightZone = camDiv.querySelector('.zone-right');
    if (rightZone) {
      camDiv.addEventListener('mouseenter', () => {
        rightZone.style.transform = 'translateX(0)';
        rightZone.style.opacity = '1';
      });
      camDiv.addEventListener('mouseleave', () => {
        rightZone.style.transform = 'translateX(10px)';
        rightZone.style.opacity = '0';
      });
    }
    // Активные состояния иконок
    icons.forEach(icon => {
    icon.addEventListener('mousedown', () => { icon.style.transform = 'scale(0.95)'; });
    icon.addEventListener('mouseup',   () => { icon.style.transform = ''; });
    icon.addEventListener('mouseleave',() => { icon.style.transform = ''; });
    });
    // Выход из fullscreen по клику на карточку
    function fullscreenClickHandler() {
      if (document.fullscreenElement === camDiv) {
        document.exitFullscreen();
        camDiv.classList.remove('fullscreen');
      }
    }
    camDiv.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement === camDiv) {
        camDiv.addEventListener('click', fullscreenClickHandler);
      } else {
        camDiv.removeEventListener('click', fullscreenClickHandler);
      }
    });

    // Полноэкран и модал
    if (expandIcon) {
      expandIcon.addEventListener('click', (e) => {
        // Если expand-icon неактивен (btn-disabled), не делаем ничего
        if (expandIcon.classList.contains('btn-disabled')) return;
        e.stopPropagation();
        const camera = e.target.closest('.camera-box');
        if (!camera) return;
        if (isModalOpen) {
          closeModal();
          enterFullscreen(camera);
        } else {
          if (isFullscreen) document.exitFullscreen();
          else enterFullscreen(camera);
        }
      });
    }
    if (manageIcon) {
      manageIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        const camera = e.target.closest('.camera-box');
        if (isFullscreen) {
          document.exitFullscreen();
          openModal(camera);
        } else {
          if (isModalOpen) closeModal();
          else openModal(camera);
        }
      });
    }
    // === Drag & drop ===
    camDiv.addEventListener('dragstart', e => {
      const isDammy = camDiv.dataset.ip === 'dammy';
      camDiv.style.opacity = isDammy ? '0.6' : '0.5';
      camDiv.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });
    camDiv.addEventListener('dragend', function() {
      const isDammy = this.dataset.ip === 'dammy';
      const isDisconnected = this.classList.contains('camera-disconnected');
      if (isDammy) this.style.opacity = '0';
      else this.style.opacity = '1';
      this.classList.remove('dragging');
      debouncedSaveOnDragEnd();
    });
    camDiv.addEventListener('dragover', e => {
      e.preventDefault();
      camDiv.classList.add('drag-over');
      if (camDiv.dataset.ip === 'dammy') camDiv.style.opacity = '0.6';
    });
    camDiv.addEventListener('dragleave', e => {
      e.preventDefault();
      camDiv.classList.remove('drag-over');
      if (camDiv.dataset.ip === 'dammy') camDiv.style.opacity = '0';
    });
    camDiv.addEventListener('drop', e => {
      e.preventDefault();
      camDiv.classList.remove('drag-over');
      const dragging = document.querySelector('.camera-box.dragging');
      if (dragging && dragging !== camDiv) {
        Elements.cameraContainer.insertBefore(dragging, camDiv.nextSibling);
        Elements.cameraContainer.insertBefore(camDiv, dragging.nextSibling);
        saveToLocalStorage();
      }
      if (camDiv.dataset.ip === 'dammy') camDiv.style.opacity = '0';
    });

    // === Мелкие UI действия ===
    // Эффект появления кнопки
    const button = camDiv.querySelector('.button');
    let hideTimeout;
    camDiv.addEventListener('mouseenter', () => {
      if (button) {
        button.classList.remove('opacity-0');
        button.style.opacity = '';
      }
      if (hideTimeout) clearTimeout(hideTimeout);
    });
    camDiv.addEventListener('mouseleave', () => {
      if (button) {
        hideTimeout = setTimeout(() => {
          button.classList.add('opacity-0');
        }, 1000);
      }
    });

    camDiv.addEventListener('click', ev => {
      if (!ev.target.closest('button')) {
        if (camDiv.dataset.ip === 'dammy') {
          enqueueNotification("Пустой слот не поддерживает полноэкранный режим", "info");
          return;
        }
      }
    });

    Elements.cameraContainer.appendChild(camDiv);
  });

  // === Финальные обновления сетки и разделителей ===
  updateGrid();
  debouncedUpdateDividers();
}


function hideLoader() {
  const loader = document.getElementById('loaderOverlay');
  if (!loader) return;
  loader.style.opacity = '0';
  setTimeout(() => loader.remove(), 500);
}

// === DIVIDERS ===
function getDividerGradient(startAlpha = "77", endAlpha = "E6") {
  const color = Elements.dividerColorInput.value;    // Цвет разделителя (основной)
  const color1 = Elements.color1Input.value;         // Градиент 1
  const color2 = Elements.color2Input.value;         // Градиент 2
  return `linear-gradient(90deg,
    ${color1}00 0%,
    ${color1}${startAlpha} 5%,
    ${color}${endAlpha} 45%,
    ${color}${endAlpha} 55%,
    ${color2}${startAlpha} 95%,
    ${color2}00 100%
  )`;
}

function updateHorizontalDividers() {
  document.querySelectorAll('.horizontal-divider, .divider-hitbox').forEach(el => el.remove());
  if (!Elements.enableDividersCheckbox.checked) return;

  const container = Elements.cameraContainer;
  if (!container) return;

  const items = Array.from(container.getElementsByClassName('camera-box'));
  if (items.length === 0) return;

  const cols = parseInt(Elements.gridColumnsInput.value || 3);
  const rows = Math.ceil(items.length / cols);
  const rowsMap = [];

  for (let i = 0; i < rows; i++) {
    rowsMap.push(items.slice(i * cols, (i + 1) * cols));
  }

  const dividerStates = JSON.parse(localStorage.getItem('dividerVisibility') || '{}');

  // Получаем настройки выравнивания и ширины
  const align = Elements.dividerAlignInput.value;
  const widthPercent = parseFloat(Elements.dividerWidthInput.value); // Ширина в процентах

  for (let i = 1; i < rows; i++) {
    const previousRowLastItem = rowsMap[i - 1][cols - 1];
    if (!previousRowLastItem) continue;

    const rect = previousRowLastItem.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();

    const divider = document.createElement('div');
    divider.className = 'horizontal-divider';
    divider.dataset.rowIndex = i;

    let leftOffset = 0;
    const containerWidth = container.clientWidth;

    // Расчет ширины и позиции
    const dividerWidthPx = (containerWidth * widthPercent) / 100;
    switch (align) {
      case 'left':
        leftOffset = 0;
        break;
      case 'center':
        leftOffset = (containerWidth - dividerWidthPx) / 2;
        break;
      case 'right':
        leftOffset = containerWidth - dividerWidthPx;
        break;
    }

    Object.assign(divider.style, {
      position: 'absolute',
      left: `${leftOffset}px`,
      width: `${dividerWidthPx}px`,
      right: 'auto', // Отключаем right, чтобы работало left
      top: `${rect.bottom - containerRect.top + 10}px`,
      height: `${Elements.dividerThicknessInput.value}px`,
      backgroundImage: `linear-gradient(90deg, transparent 0%, ${Elements.dividerColorInput.value}77 35%, ${Elements.dividerColorInput.value}cc 65%, transparent 100%)`,
      zIndex: '0',
      cursor: 'pointer',
      transition: 'opacity 0.3s, background-color 0.3s'
    });

    const key = `row_${i}`;
    const isVisible = dividerStates[key] !== false;
    if (isVisible) {
      divider.style.opacity = '1';
      applyDividerGradient(divider); // <-- Восстанавливаем градиент
    } else {
      divider.style.opacity = '0';
    }

    // Обработчики событий для hover и клика
    divider.addEventListener('mouseenter', () => {
      const currentOpacity = parseFloat(divider.style.opacity || 1);
      divider.dataset.originalOpacity = currentOpacity;
      if (currentOpacity > 0.5) {
        divider.style.opacity = '0.8';
        applyDividerGradient(divider);
      } else {
        divider.style.opacity = '0.2';
        applyDividerGradient(divider);
      }
    });
    divider.addEventListener('mouseleave', () => {
      const currentOpacity = parseFloat(divider.style.opacity || 1);
      let newOpacity = currentOpacity < 0.5 ? 0 : 1;
      divider.style.opacity = newOpacity;
      divider.style.backgroundImage = getDividerGradient();
      divider.style.backgroundRepeat = 'no-repeat';
      divider.style.backgroundSize = '100% 100%';
      const key = `row_${divider.dataset.rowIndex}`;
      const dividerStates = JSON.parse(localStorage.getItem('dividerVisibility') || '{}');
      const newStates = { ...dividerStates, [key]: newOpacity !== 0 };
      localStorage.setItem('dividerVisibility', JSON.stringify(newStates));
    });
    divider.addEventListener('click', (e) => {
      e.stopPropagation();
      const currentOpacity = parseFloat(divider.style.opacity || 1);
      const newOpacity = currentOpacity < 0.5 ? 1 : 0;
      divider.style.opacity = newOpacity;
      divider.style.backgroundImage = getDividerGradient();
      divider.style.backgroundRepeat = 'no-repeat';
      divider.style.backgroundSize = '100% 100%';
      const key = `row_${i}`;
      const dividerStates = JSON.parse(localStorage.getItem('dividerVisibility') || '{}');
      const newStates = { ...dividerStates, [key]: newOpacity !== 0 };
      localStorage.setItem('dividerVisibility', JSON.stringify(newStates));
    });

    // Добавляем hitbox
    const hitbox = document.createElement('div');
    hitbox.className = 'divider-hitbox';
    hitbox.dataset.rowIndex = i;
    Object.assign(hitbox.style, {
      position: 'absolute',
      left: `${leftOffset}px`,
      width: `${dividerWidthPx}px`,
      right: 'auto',
      top: `${rect.bottom - containerRect.top - 10}px`,
      height: '40px',
      zIndex: '0',
      cursor: 'pointer',
      opacity: '0'
    });

    hitbox.addEventListener('mouseenter', () => {
      divider.dispatchEvent(new MouseEvent('mouseenter', { bubbles: true }));
    });
    hitbox.addEventListener('mouseleave', () => {
      divider.dispatchEvent(new MouseEvent('mouseleave', { bubbles: true }));
    });
    hitbox.addEventListener('click', (e) => {
      e.stopPropagation();
      divider.click();
    });

    container.appendChild(hitbox);
    container.appendChild(divider);
  }
}

function syncDividerStyles() {
  const thickness = Elements.dividerThicknessInput.value;
  document.querySelectorAll('.horizontal-divider').forEach(divider => {
    divider.style.backgroundImage = getDividerGradient();
    divider.style.backgroundRepeat = 'no-repeat';
    divider.style.backgroundSize = '100% 100%';
    divider.style.height = `${thickness}px`;
  });
}

function applyDividerGradient(divider) {
  const color = Elements.dividerColorInput.value;     // Цвет разделителя (основной)
  const color1 = Elements.color1Input.value;          // Градиент 1
  const color2 = Elements.color2Input.value;          // Градиент 2
  divider.style.backgroundImage = getDividerGradient(color, color1, color2);
  divider.style.backgroundRepeat = 'no-repeat';
  divider.style.backgroundSize = '100% 100%';
}

// === NOTIFICATIONS ===
let notificationQueue = [];
let isProcessing = false;
const NOTIFICATION_DELAY = 300; // Задержка между уведомлениями
let notificationCounter = 0;
let activeNotifications = new Set();
const notificationBuffer = new Set(); // Буфер временных уведомлений
let bufferTimer = null; // Таймер для отложенной отправки
let globalCollapseTimeout = null;
let hoveredNotificationsCount = 0; // Счетчик наведённых уведомлений

function getNotificationStyles(isSystem = false) {
  const colorInput = isSystem ? Elements.systemNotificationColorInput : Elements.errorNotificationColorInput;
  const opacityInput = isSystem ? Elements.notificationOpacityInput : Elements.notificationOpacityInput;
  const color = colorInput.value || "#ff4d4d";
  const opacity = +opacityInput.value || 0.2;

  const r = parseInt(color.substr(1, 2), 16);
  const g = parseInt(color.substr(3, 2), 16);
  const b = parseInt(color.substr(5, 2), 16);

  return {
    color: `rgba(${r},${g},${b},${opacity})`,
    border: `rgba(${r},${g},${b},${Math.max(opacity * 0.7, 0.25)})`
  };
}

//Собираем полученные уведомления в стэк
const activeNotificationsBuffer = new Set(); // Уже есть в твоём коде
function addToBuffer(message, type = "info") {
  // Проверяем на дубликат
  if (checkAndRemoveDuplicateBuffer(message)) return;
  // Добавляем в буфер
  notificationBuffer.add(JSON.stringify({ message, type }));
  // Сбрасываем таймер
  if (bufferTimer) clearTimeout(bufferTimer);
  // Запускаем таймер на 3 секунды
  bufferTimer = setTimeout(() => {
    flushBuffer();
  }, 900);
}
function checkAndRemoveDuplicateBuffer(message) {
  if (activeNotificationsBuffer.has(message)) {
    return true; // Это дубликат
  }
  return false;
}

//Очещаем буфер и отправляем в очаредь
function flushBuffer() {
  if (notificationBuffer.size === 0) return;
  for (const item of notificationBuffer) {
    const { message, type } = JSON.parse(item);
    const wasDuplicate = checkAndRemoveDuplicate(message);
    activeNotifications.add(message); // Добавляем в активные
    notificationQueue.push([message, type]); // В очередь на показ
  }
  notificationBuffer.clear(); // Очищаем буфер
  processNotificationQueue(); // Обрабатываем очередь
}

// Ищем дубли и закрываем их
function checkAndRemoveDuplicate(message) {
  const container = document.getElementById("notificationContainer");
  if (!container) return false;

  const cleanMessage = stripHtml(message).trim();

  const existing = Array.from(container.querySelectorAll(".notification")).find(notification => {
    const span = notification.querySelector("span");
    const text = span ? span.textContent.trim() : '';
    return text === cleanMessage;
  });

  if (existing) {
    animateAndRemoveNotification(existing); // корректное удаление с анимацией
    return true;
  }
  return false;
}

// Удаляем html тэги
function stripHtml(html) {
  const tmp = document.createElement("div");
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || "";
}

// Задаем Z-index
function updateNotificationZIndices() {
  const container = document.getElementById("notificationContainer");
  if (!container) return;

  // Получаем все уведомления, включая свернутые и не свернутые
  const notifications = Array.from(container.querySelectorAll(".notification"));

  notifications.forEach((notification, index) => {
    notification.style.zIndex = 40 + index;
  });
}

// Обновление номера и позиции
let isUpdatingPositions = false;

function schedulePositionUpdate() {
  if (isUpdatingPositions) return;
  isUpdatingPositions = true;

  requestAnimationFrame(() => {
    updateAllNotificationPositions();
    isUpdatingPositions = false;
  });
}

function updateAllNotificationPositions() {
  const container = document.getElementById("notificationContainer");
  if (!container) return;
  const gap = 10;
  // Получаем уведомления, фильтруем и сортируем по data-number
  const notifications = Array.from(container.querySelectorAll(".notification"))
    .filter(n => !n.dataset.animating && n.dataset.collapsed !== 'true')
    .sort((a, b) => parseInt(a.dataset.number) - parseInt(b.dataset.number)); // Сортировка

  if (notifications.length === 0) return;

  let cumulativeBottom = 0;
  notifications.forEach((notification, index) => {
    const newNumber = index;
    notification.dataset.number = newNumber;
    notification.style.zIndex = 40 + newNumber; // Обновляем zIndex
    cumulativeBottom = newNumber * (notification.offsetHeight + gap);
    notification.style.transition = "bottom 0.6s ease";
    notification.style.bottom = `${cumulativeBottom}px`;
  });
  notificationCounter = notifications.length;
  updateNotificationZIndices();
}

function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) {
    isProcessingQueue = false;
    return;
  }

  isProcessingQueue = true;

  const { removedNumber } = positionUpdateQueue.shift(); // больше не нужен removedHeight
  const container = document.getElementById("notificationContainer");
  if (!container) return;

  const gap = 10;
  const allNotifications = Array.from(container.querySelectorAll(".notification"));

  allNotifications.forEach((notification, index) => {
    const currentNumber = parseInt(notification.dataset.number);
    const newNumber = index;

    if (currentNumber !== newNumber) {
      notification.dataset.number = newNumber;
      const newBottom = newNumber * (notificationHeight + gap);
      notification.style.transition = "bottom 0.6s ease";
      notification.style.bottom = `${newBottom}px`;
    }
  });

  notificationCounter = allNotifications.length;

  setTimeout(() => processPositionUpdateQueue(), POSITION_UPDATE_DELAY);
}

// Показ уведомлений
function processNotificationQueue() {
  if (isProcessing || notificationQueue.length === 0) return;

  isProcessing = true;
  const [message, type] = notificationQueue.shift();

  _createNotification(message, type);

  setTimeout(() => {
    isProcessing = false;
    processNotificationQueue();
  }, NOTIFICATION_DELAY);
}

// Ретранслятор передачи уведомлений
function enqueueNotification(message, type = "info") {
  if (suppressNotifications && pendingRestores > 0) {
      return; // Блокируем и system, и error уведомления
  }
  addToBuffer(message, type);
}

// Создание уведомлений
let notificationOffset = 0;
let isAnimating = false;
function _createNotification(message, type = "info") {
  if (isAnimating) {
    setTimeout(() => _createNotification(message, type), 100);
    return;
  }

  // Небольшая задержка для стабилизации DOM после удаления дубликатов
  setTimeout(() => {
    const container = document.getElementById("notificationContainer");
    if (!container) return;

    // Получаем все уведомления, исключая те, что в процессе анимации удаления
    const allNotifications = Array.from(container.querySelectorAll(".notification"))
      .filter(n => n.dataset.animating !== 'true');

    let maxNumber = allNotifications.reduce((max, el) => {
      const num = parseInt(el.dataset.number);
      return isNaN(num) ? max : Math.max(max, num);
    }, -1);

    // Проверяем, есть ли хотя бы одно свернутое уведомление
    const hasCollapsed = allNotifications.some(n => n.dataset.collapsed === 'true');

    // Количество "видимых" уведомлений
    const visibleCount = hasCollapsed 
      ? Math.min(1, allNotifications.length) 
      : allNotifications.filter(n => n.dataset.collapsed !== 'true').length;

    // Типы уведомлений
    const div = document.createElement("div");
    let iconClass = '';
    let isSystem = type === "system";
    let isError = type === "error";
    let isInfo = type === "info";

    // Уникальный номер для самого уведомления (для внутренней идентификации)
    const number = maxNumber + 1; // Присваиваем следующий по порядку номер
    notificationCounter = number + 1; // Обновляем счетчик
    div.dataset.number = number;
    notificationOffset++;

    // Стили
    div.className = `notification notif-enter flex items-center gap-3 rounded-lg shadow-md px-4 py-2 mb-1 border bg-white/90`;
    div.style.opacity = "0";
    div.style.transform = "translateY(100px)";
    div.style.transition = "opacity 0.3s ease, transform 0.3s ease, bottom 0.6s ease, filter 0.3s ease";
    div.style.position = "absolute";
    div.style.right = "0";
    div.style.zIndex = 40 + number;

    // Высота будет определена после добавления элемента в DOM
    div.style.bottom = `-50px`; // Временное значение

    if (isError) {
      const { color, border } = getNotificationStyles();
      div.style.background = color;
      div.style.borderColor = border;
      iconClass = 'fas fa-exclamation-circle';
    } else if (isSystem) {
      const { color, border } = getNotificationStyles(true);
      div.style.background = color;
      div.style.borderColor = border;
      iconClass = 'fas fa-check-circle';
    } else {
      const opacity = +Elements.notificationOpacityInput.value || 0.75;
      const bgColor = `rgb(var(--white)/${opacity})`;
      div.style.background = bgColor;
      div.style.borderColor = `rgba(255,255,255,${opacity * 0.8})`;
      iconClass = 'fas fa-info-circle';
    }

    // HTML содержимое
    if (isInfo) { div.innerHTML = `
        <i class="text-[rgba(0,0,0,0.8)] ${iconClass}" ></i>
        <span class="text-[rgba(0,0,0,0.8)] flex-1 text-sm font-medium">${message}</span>
      `;
    } else { div.innerHTML = `
        <i class="text-white-castom-80 ${iconClass}" ></i>
        <span class="text-white-castom flex-1 text-sm font-medium">${message}</span>
      `;
    }

    // Добавляем уведомление в DOM
    container.appendChild(div);
    updateNotificationZIndices();

    // СРАЗУ обновляем стили у всех свёрнутых уведомлений
    hideNonTopCollapsedNotifications();

    // Теперь можно получить точную высоту
    const height = div.offsetHeight;
    const gap = 10;

    // Позиция — только по числу НЕ свёрнутых уведомлений
    let newBottom = (hasCollapsed ? visibleCount + notificationOffset : visibleCount) * (height + gap);

    // Анимация появления
    requestAnimationFrame(() => {
      div.style.opacity = "1";
      div.style.transform = "translateY(0)";
      div.style.bottom = `${newBottom}px`;
    });

    // После окончания анимации показа — сразу обновляем стили свернутых уведомлений
    let transitionCount = 0;
    const expectedTransitions = ['opacity', 'transform', 'bottom'];
    function handleTransitionEnd(e) {
      if (expectedTransitions.includes(e.propertyName)) {
        transitionCount++;
        if (transitionCount >= expectedTransitions.length) {
          div.removeEventListener('transitionend', handleTransitionEnd);
          hideNonTopCollapsedNotifications();
        }
      }
    }
    div.addEventListener('transitionend', handleTransitionEnd);

    // Очищаем старый таймер, если он был
    if (div.dataset.collapseTimeout) {
      clearTimeout(div.dataset.collapseTimeout);
      delete div.dataset.collapseTimeout;
    }

    // HOVER эффект
    div.addEventListener('mouseenter', () => {
      div.style.transform = 'translateX(5%) scale(0.9)';
      div.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
      hoveredNotificationsCount++;
      clearTimeout(globalCollapseTimeout);
    });
    div.addEventListener('mouseleave', () => {
      div.style.transform = 'translateX(0) scale(1)';
      div.style.boxShadow = 'none';
      hoveredNotificationsCount--;
      if (hoveredNotificationsCount <= 0) {
        startGlobalCollapseTimer();
      }
    });
    // Закрытие по клику
    div.addEventListener('click', function () {
      animateAndRemoveNotification(this);
    });

    if (hoveredNotificationsCount === 0) {
      startGlobalCollapseTimer(); // Запускаем таймер, если никто не наведён
    }

  }, 800); // ⏱️ Задержка в 100 мс для обновления DOM
}

// Удалением элемента из DOM и обновлением данных
function _removeNotificationElement(div) {
  const container = document.getElementById("notificationContainer");
  const allNotifications = Array.from(container.querySelectorAll(".notification"));

  // Обновляем notificationCounter на основе актуального количества
  notificationCounter = allNotifications.length;

  // Убираем из activeNotifications, если нужно
  const innerHTML = div.querySelector("span")?.innerHTML.trim();
  if (innerHTML) {
    activeNotifications.delete(innerHTML);
  }

  // Удаляем сам элемент
  div.remove();

  // Обновляем позиции только если уведомление было развернутым
  if (!div.classList.contains('collapsed')) {
    schedulePositionUpdate();
  }
  // Обновляем отображение свёрнутых уведомлений
  setTimeout(hideNonTopCollapsedNotifications, 300); // Ждём завершения анимации
}

// Функция програмного закрытия уведомления
function closeNotificationByDataNumber(targetNumber) {
  const container = document.getElementById("notificationContainer");
  const allNotifications = container.querySelectorAll(".notification");

  const foundDiv = Array.from(allNotifications).find(div =>
      parseInt(div.dataset.number) === targetNumber
  );

  if (!foundDiv) {
    console.warn(`Элемент с data-number="${targetNumber}" не найден`);
    return;
  }

  animateAndRemoveNotification(foundDiv);
}
// closeNotificationByDataNumber(42); // Закроет уведомление с data-number="42"

// Универсальная функция для запуска анимации удаления уведомления
function animateAndRemoveNotification(div) {
  if (!div || div.dataset.animating === 'true') return;
  div.dataset.animating = 'true';

  // Если уведомление свернуто — удаляем без анимации
  if (div.classList.contains('collapsed')) {
    _removeNotificationElement(div);
    return;
  }

  // Иначе применяем анимацию
  const removedHeight = div.offsetHeight;
  div.classList.add("wave-out");

  div.addEventListener('animationend', () => {
    _removeNotificationElement(div);
  }, { once: true });
}

// === Логика сварачивания стека уведомлений ===
// Определение свернутых уведомлений
const notificationActions = document.getElementById('notificationActions');
function getCollapsedNotifications() {
  const container = document.getElementById("notificationContainer");
  if (!container) return [];
  return Array.from(container.querySelectorAll(".notification")).filter(n => n.dataset.collapsed === 'true');
}

// Функция запуска таймера сворачивания
function startGlobalCollapseTimer() {
  clearTimeout(globalCollapseTimeout);
  globalCollapseTimeout = setTimeout(() => {
    const allNotifications = document.querySelectorAll(".notification");
    allNotifications.forEach(notification => {
      if (!notification.classList.contains('collapsed') && !notification.dataset.animating) {
        collapseNotification(notification);
      }
    });
    notificationOffset = 0; // Сбрасываем счётчик смещения
  }, NOTIFICATION_COLLAPSE_DELAY); // Например, 5000 мс
}

// Функция сварачивания
const NOTIFICATION_COLLAPSE_DELAY = 5000; // 5 секунд
function collapseNotification(notificationElement) {
  if (!notificationElement || 
    notificationElement.dataset.collapsed === 'true' || 
    notificationElement.closest('.camera-disconnected')) return;

  const container = document.getElementById("notificationContainer");

  // Получаем список ВСЕХ уведомлений (включая свёрнутые и анимируемые)
  const allNotifications = Array.from(container.querySelectorAll(".notification"));

  // Проверяем, было ли изначально более одного уведомления
  if (allNotifications.length <= 1) return;

  notificationElement.dataset.collapsed = 'true';
  hideNonTopCollapsedNotifications();
  notificationElement.classList.add('collapsed');

  // После завершения анимации показываем кнопки действий
  setTimeout(() => {
    const collapsedList = getCollapsedNotifications();
    if (collapsedList.length > 0 && notificationActions) {
      notificationActions.classList.remove('hidden');
      notificationActions.classList.add('show');
    }
    hideNonTopCollapsedNotifications();
  }, 300); // <-- Запускаем скрытие
}

//Функция разворачивани
function expandNotification(notificationElement) {
  if (!notificationElement || 
    notificationElement.dataset.collapsed !== 'true' || 
    notificationElement.closest('.camera-disconnected')) return;

  delete notificationElement.dataset.collapsed;
  notificationElement.classList.remove('collapsed');

  // Восстанавливаем оригинальный opacity
  if (notificationElement.dataset.originalOpacity) {
    notificationElement.style.opacity = notificationElement.dataset.originalOpacity;
    notificationElement.style.pointerEvents = "auto"; // Возвращаем взаимодействие
  }

  updateNotificationZIndices();
  schedulePositionUpdate();
  startGlobalCollapseTimer();
}
const expandNotificationsBtn = document.getElementById('expandNotificationsBtn');
const closeAllNotificationsBtn = document.getElementById('closeAllNotificationsBtn');

// Функция для скрытия уведомления
function hideNonTopCollapsedNotifications() {
  const collapsed = getCollapsedNotifications();
  const container = document.getElementById("notificationContainer");
  if (!container) return;

  const collapsedNotifications = getCollapsedNotifications();
  if (collapsedNotifications.length <= 0) return;

  const maxNumber = Math.max(...collapsedNotifications.map(n => parseInt(n.dataset.number)));

  collapsedNotifications.forEach(notification => {
    const number = parseInt(notification.dataset.number);

    if (number < maxNumber) {
      notification.style.filter = "blur(4px)";
      notification.style.opacity = "0.2"; // Можно дополнительно
    } else {
      notification.style.filter = "none";
      notification.style.opacity = "1";
    }
  });
}

// === Сохранение в память браузера ===
function saveToLocalStorage() {
  if (!State.allowLocalStorage) return;

  const cameras = getCameraTableData();
  const cameraElements = document.querySelectorAll('.camera-box');
  const orderMap = {};

  cameraElements.forEach((el, index) => {
    const ip = el.dataset.ip;
    orderMap[ip] = index;
  });

  const orderedCameras = [...cameras].sort((a, b) => (orderMap[a.ip] || 0) - (orderMap[b.ip] || 0));

  const settings = {
    namedDriv: +Elements.namedDrivInput.value,
    cameraOrder: getCameraTableData().map(cam => ({ ip: cam.ip, stream: cam.stream, name: cam.name })),
    color1: Elements.color1Input.value,
    color2: Elements.color2Input.value,
    colorIntOver: Elements.colorIntOverInput.value,
    errorNotificationColor: Elements.errorNotificationColorInput.value,
    notificationOpacity: Elements.notificationOpacityInput.value,
    systemNotificationColor: Elements.systemNotificationColorInput.value,
    toolbarIconRgb: updateActionIconColors(),
    loader: {
      hide: Elements.hideLoaderCheckbox.checked,
      bgColor: Elements.loaderBgColorInput.value,
      opacity: Elements.loaderOpacityInput.value,
      offFullCheckbox: Elements.offFullCheckbox.checked,
    },
    enableDividers: Elements.enableDividersCheckbox.checked,
    dividerColor: Elements.dividerColorInput.value,
    dividerThickness: Elements.dividerThicknessInput.value,
    dividerAlign: Elements.dividerAlignInput.value,
    dividerWidth: Elements.dividerWidthInput.value,
    namedDriv: Elements.namedDrivInput.value,
    grid: {
      columns: +Elements.gridColumnsInput.value
    },
    header: {
      text: Elements.headerTextInput.value,
      hidden: Elements.hideHeaderCheckbox.checked,
      bgColor: Elements.headerBgColorInput.value,
      bgOpacity: +Elements.headerBgOpacityInput.value,
      textColor: Elements.headerTextColorInput.value
    },
    interfaceWidth: +Elements.interfaceWidthInput.value,
  };

  localStorage.setItem('printerCamsV2', JSON.stringify(settings));
}

function loadFromLocalStorage() {
  if (!State.allowLocalStorage) return false;
  const data = localStorage.getItem('printerCamsV2');
  if (!data) return false;
  try {
    const settings = JSON.parse(data);
    const defaults = Config.defaultSettings;
    const savedCameras = settings.cameraOrder || Config.defaultCameras;
    const camerasArr = savedCameras.map(cam => {
      if (typeof cam === 'string') {
        return { ip: cam, stream: '', name: "" };
      } else if (typeof cam === 'object' && cam.ip) {
        return {
          ip: cam.ip,
          stream: typeof cam.stream === 'string' ? cam.stream : '',
          name: typeof cam.name === 'string' ? cam.name : ''
        };
      }
      return { ip: '', stream: '', name: '' };
    });
    loadCameras(camerasArr);
    // Устанавливаем средний цвет из сохраненных настроек
    if (settings.toolbarIconRgb) {
      const { r, g, b } = settings.toolbarIconRgb;
      document.documentElement.style.setProperty(
        '--base-color-rgb',
        `${r} ${g} ${b}`
      );
    } else {
      // Если сохраненного среднего цвета нет, вычисляем его
      updateActionIconColors();
    }
    renderCameraTable(savedCameras);
    Elements.color1Input.value = settings.color1 || defaults.color1;
    Elements.color2Input.value = settings.color2 || defaults.color2;
    Elements.colorIntOverInput.value = settings.colorIntOver || defaults.colorIntOver;
    Elements.errorNotificationColorInput.value = settings.errorNotificationColor || defaults.errorNotificationColor;
    Elements.systemNotificationColorInput.value = settings.systemNotificationColor || defaults.systemNotificationColor;
    Elements.notificationOpacityInput.value = settings.notificationOpacity || defaults.notificationOpacity;

    Elements.hideLoaderCheckbox.checked = settings.loader?.hide ?? defaults.loader.hide;
    Elements.loaderBgColorInput.value = settings.loader?.bgColor || defaults.loader.bgColor;
    Elements.loaderOpacityInput.value = settings.loader?.opacity ?? defaults.loader.opacity;
    Elements.offFullCheckbox.checked = settings.loader?.offFullCheckbox ?? defaults.loader.offFullCheckbox;

    Elements.gridColumnsInput.value = settings.grid?.columns ?? defaults.grid.columns;
    Elements.headerTextInput.value = settings.header?.text ?? defaults.header.text;
    Elements.hideHeaderCheckbox.checked = settings.header?.hidden ?? defaults.header.hidden;
    Elements.headerBgColorInput.value = settings.header?.bgColor ?? defaults.header.bgColor;
    Elements.headerBgOpacityInput.value = settings.header?.bgOpacity ?? defaults.header.bgOpacity;
    Elements.headerTextColorInput.value = settings.header?.textColor ?? defaults.header.textColor;

    const savedWidth = settings.interfaceWidth ?? defaults.interfaceWidth;
    Elements.interfaceWidth.value = savedWidth;
    Elements.interfaceWidthInput.value = savedWidth;

    Elements.dividerColorInput.value = settings.dividerColor ?? defaults.dividerColor;
    Elements.dividerThicknessInput.value = settings.dividerThickness ?? defaults.dividerThickness;
    Elements.dividerAlignInput.value = settings.dividerAlign ?? defaults.dividerAlign;
    Elements.dividerWidthInput.value = settings.dividerWidth ?? defaults.dividerWidth;
    Elements.dividerWidthValue.textContent = (settings.dividerWidth ?? defaults.dividerWidth) + '%';
    Elements.enableDividersCheckbox.checked = settings.enableDividers ?? defaults.enableDividers;
    Elements.namedDrivInput.value = settings.namedDriv || Config.defaultSettings.namedDriv;
    Elements.namedDrivValue.textContent = settings.namedDriv + 'rem' || Config.defaultSettings.namedDriv + 'rem';

    updateNotificationOpacity();
    updateHeader();
    updateGrid();
    updateInterfaceWidth();
    updateToolbarVisibility();
    updateToolbarColors();
    updateLoader();
    debouncedUpdateDividers();

    return true;
  } catch (e) {
    console.error("Ошибка при загрузке данных из localStorage:", e);
    return false;
  }
}

// === CONSENT MODAL ===
// В функцию showConsent() добавьте в самом конце:
function showConsent() {
  const consentModal = document.getElementById('consentModal');
  const loader = document.getElementById('loaderOverlay');
  
  // === ЛОГИКА ДЛЯ ПЕРЕКЛЮЧЕНИЯ СЕКЦИЙ ===
  toggleSections(!State.allowLocalStorage);
  
  if (consentModal) {
    consentModal.classList.remove('hidden');
    if (loader) {
      loader.classList.add('hidden');
      loader.style.opacity = '0';
      loader.style.display = 'none';
    }
  }

  Elements.allowConsentBtn.onclick = () => {
    State.allowLocalStorage = true;
    localStorage.setItem('printerCamsV2Consent', 'yes');
    consentModal.classList.add('hidden');
    
    // === ПЕРЕКЛЮЧАЕМ СЕКЦИИ ПРИ ПРИНЯТИИ ===
    toggleSections(false);

    if (loader) {
      loader.classList.remove('hidden');
      loader.style.display = 'flex';
      setTimeout(() => {
        loader.style.opacity = '1';
      }, 10);
    }

    if (!loadFromLocalStorage()) {
      loadCameras(Config.defaultCameras);
    }
    renderCameras();
    updateInterfaceWidth();
    updateToolbarVisibility();
    location.reload();
  };

  Elements.denyConsentBtn.onclick = () => {
    State.allowLocalStorage = false;
    window.location.href = 'print%20.html';
  };
}

// Вспомогательная функция toggleSections() уже есть в вашем коде:
function toggleSections(showStart) {
  const startSections = document.querySelectorAll('section[id="Start"]');
  const endSections = document.querySelectorAll('section[id="End"]');

  startSections.forEach(el => {
    el.classList.toggle('hidden', !showStart);
  });

  endSections.forEach(el => {
    el.classList.toggle('hidden', showStart);
  });
}

// === TOOLBAR VISIBILITY ===
function updateToolbarVisibility() {
  const toolbar = document.getElementById('toolbar');
  if (!toolbar) return;

  if (Elements.hideHeaderCheckbox.checked) {
    if (!State.floatingToolbar) {
      State.floatingToolbar = document.createElement('div');
      State.floatingToolbar.id = 'floatingToolbar';
      State.floatingToolbar.className = 'fixed top-0 right-0 w-52 h-16 pointer-events-none z-50 opacity-0 transition-opacity duration-200';
      const inner = document.createElement('div');
      inner.className = 'backdrop-blur-sm rounded-xl shadow-lg p-3 mt-4 mr-4 flex justify-end gap-2 pointer-events-auto';
      inner.style.background = 'linear-gradient(135deg, rgb(var(--scrollableTableH-rgb)), rgb(var(--scrollableTableB-rgb)))';
      inner.style.border = '2px solid rgb(var(--shadow-rgb))';
      inner.appendChild(toolbar);
      State.floatingToolbar.appendChild(inner);
      document.body.appendChild(State.floatingToolbar);

      const triggerArea = document.createElement('div');
      triggerArea.id = 'headerTriggerArea';
      triggerArea.className = 'fixed top-0 right-0 w-screen h-16 cursor-default z-40';
      document.body.appendChild(triggerArea);

      triggerArea.addEventListener('mouseenter', () => {
        State.floatingToolbar.style.opacity = '1';
      });

      State.floatingToolbar.addEventListener('mouseleave', () => {
        State.floatingToolbar.style.opacity = '0';
      });
    }
  } else {
    if (State.floatingToolbar) {
      State.floatingToolbar.remove();
      State.floatingToolbar = null;
    }
    const toolbarContainer = document.getElementById('toolbarContainer');
    if (!toolbarContainer) {
      const newContainer = document.createElement('div');
      newContainer.id = 'toolbarContainer';
      newContainer.appendChild(toolbar);
      const flexContainer = document.querySelector('#headerBar .flex');
      if (flexContainer) {
        flexContainer.appendChild(newContainer);
      }
    } else {
      toolbarContainer.innerHTML = '';
      toolbarContainer.appendChild(toolbar);
    }
  }
}

// === LOADER ===
function updateLoader() {
  const loader = document.getElementById('loaderOverlay');
  const consentModal = document.getElementById('consentModal');

  if (!loader) return;

  // Если чекбокс включен - сразу скрываем лоадер
  if (Elements.hideLoaderCheckbox.checked) {
    loader.classList.add('hidden');
    loader.style.opacity = '0';
    loader.style.display = 'none';
    return;
  }

  const isConsentVisible = consentModal && !consentModal.classList.contains('hidden');
  if (isConsentVisible) {
    loader.classList.add('hidden');
    loader.style.opacity = '0';
    return;
  }

  loader.classList.remove('hidden');
  loader.style.display = 'flex';
  setTimeout(() => {
    loader.style.opacity = '1';
  }, 10);

  const bgColor = Elements.loaderBgColorInput.value;
  const opacity = Elements.loaderOpacityInput.value;

  // Используем существующую функцию hexToRgb
  const rgb = hexToRgb(bgColor);
  if (rgb) {
    loader.style.backgroundColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
  } else {
    // fallback на черный, если что-то пошло не так
    loader.style.backgroundColor = `rgb(17, 17, 17, ${opacity})`;
  }
}

// === FULLSCREEN HANDLER ===
document.addEventListener('fullscreenchange', () => {
  document.querySelectorAll('.camera-box.fullscreen').forEach(el => {
    el.classList.remove('fullscreen');
  });
});

// === HELP MODAL ===
Elements.helpBtn.addEventListener('click', () => Elements.helpModal.classList.remove('hidden'));
Elements.closeHelpBtn.addEventListener('click', () => Elements.helpModal.classList.add('hidden'));
Elements.helpModal.addEventListener('click', e => {
  if (!e.target.closest('.bg-white')) Elements.helpModal.classList.add('hidden');
});
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') Elements.helpModal.classList.add('hidden');
});

// === STARTUP ===
document.addEventListener('DOMContentLoaded', () => {
  window.lucide && lucide.createIcons();
  // === HELP MODAL LOGIC ===
  function showModal() {
    Elements.helpModal.setAttribute('aria-hidden', 'false');
    Elements.helpModal.classList.remove('invisible', 'opacity-0');
    Elements.helpModal.classList.add('flex');
    Elements.modalDialog.classList.remove('modal-fade-out');
    Elements.modalDialog.classList.add('modal-fade-in');
    setTimeout(() => Elements.helpModal.classList.add('opacity-100'), 10);
  }

  function hideModal() {
    Elements.modalDialog.classList.remove('modal-fade-in');
    Elements.modalDialog.classList.add('modal-fade-out');
    Elements.helpModal.classList.remove('opacity-100');
    setTimeout(() => {
      Elements.helpModal.classList.remove('flex');
      Elements.helpModal.classList.add('invisible', 'opacity-0');
      Elements.helpModal.setAttribute('aria-hidden', 'true');
      Elements.helpBtn.focus();
    }, 330);
  }

  // Обработчики событий
  Elements.helpBtn.addEventListener('click', showModal);
  Elements.closeHelpBtn.addEventListener('click', hideModal);

  Elements.helpModal.addEventListener('mousedown', e => {
    if (e.target === Elements.helpModal) hideModal();
  });

  document.addEventListener('keydown', e => {
    if (Elements.helpModal.classList.contains('flex') && e.key === 'Escape') hideModal();
  });

  document.querySelectorAll('.social-btn').forEach(btn => {
    btn.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') btn.click();
    });
  });
  if (Elements.toolbar) {
    // Поиск всех кнопок с классом glass-btn
    Elements.toolbar.querySelectorAll('.glass-btn').forEach(button => {
      // Обработчик наведения мыши - показывает подсказку
      button.addEventListener('mouseenter', () => {
          const tooltip = button.querySelector('.custom-tooltip');
          if (tooltip) {
              tooltip.style.opacity = '1';
              tooltip.style.pointerEvents = 'auto';
          }
      });
      // Каждой добавление обработчика клика
      button.addEventListener('click', () => {
        // При клике ищется элемент с классом 'custom-tooltip' внутри этой кнопки
        const tooltip = button.querySelector('.custom-tooltip');
        // Если подсказка найдена
        if (tooltip) {
          // Устанавливается прозрачность в 0 (делает подсказку невидимой и неинтерактивной)
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
        }
      });
      // Добавление обработчика при уходе мыши
      button.addEventListener('mouseleave', () => {
        // При уходе Ищется элемент подсказки
        const tooltip = button.querySelector('.custom-tooltip');
        if (tooltip) {
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
        }
      });
    });
  }
  init();
  updateBorderRightValue();
  updateCameraTitleFontSize();
  setTimeout(() => {
    debouncedUpdateDividers();
  }, 0);
  if (!localStorage.getItem('printerCamsV2Consent')) {
    showConsent();
  } else {
    State.allowLocalStorage = true;
    if (!loadFromLocalStorage()) {
      loadCameras(Config.defaultCameras);
      renderCameraTable(Config.defaultCameras);
    }
    renderCameraTable();
    renderCameras();
    updateInterfaceWidth();
  }

  Elements.headerTextColorInput.addEventListener('input', () => {
    updateHeader();
    updateToolbarColors();
  });

  Elements.dividerThicknessInput.addEventListener('input', updateBorderRightValue);

  document.addEventListener('fullscreenchange', () => {
    document.querySelectorAll('.camera-box.fullscreen').forEach(el => {
      el.classList.remove('fullscreen');
    });
  });
});

function updateBorderRightValue() {
  document.documentElement.style.setProperty('--border-right', `${Elements.dividerThicknessInput.value}px`);
}
lucide.createIcons({strokeWidth:1.5});

// reveal on scroll
const observeri=new IntersectionObserver(e=>e.forEach(i=>i.isIntersecting&&i.target.classList.add('show')), {threshold:.15});
document.querySelectorAll('.reveal').forEach(el=>observeri.observe(el));

// hints
const aBtn=document.getElementById('allowConsentBtn'), dBtn=document.getElementById('denyConsentBtn'),
      aHint=document.getElementById('acceptHint'), dHint=document.getElementById('declineHint'), 
      cBtn=document.getElementById('consetModalCloseBtn'), cHint=document.getElementById('closeHint');
const hide=()=>{aHint.style.opacity=0;dHint.style.opacity=0;cHint.style.opacity=0;};
aBtn.onmouseenter=()=>{hide();aHint.style.opacity=1};
dBtn.onmouseenter=()=>{hide();dHint.style.opacity=1};
cBtn.onmouseenter=()=>{hide();cHint.style.opacity=1};
[aBtn, dBtn, cBtn, aHint.parentElement, dHint.parentElement, cHint.parentElement].forEach(el => el.onmouseleave = hide);

aBtn.onclick=()=>alert('Условия приняты!');
dBtn.onclick=()=>alert('Спасибо за проявленый интерес. Доступ закрыт.');

function toggleSections(showStart) {
  const startSections = document.querySelectorAll('section[id="Start"]');
  const endSections = document.querySelectorAll('section[id="End"]');

  startSections.forEach(el => {
    el.style.display = showStart ? 'block' : 'none';
  });

  endSections.forEach(el => {
    el.style.display = !showStart ? 'block' : 'none';
  });
}
document.getElementById('consetModalBtn')?.addEventListener('click', () => {
  const modal = document.getElementById('consentModal');
  toggleSections(false)
  if (modal) {
    modal.classList.remove('hidden');
  }
});
document.getElementById('consetModalCloseBtn')?.addEventListener('click', () => {
  const modal = document.getElementById('consentModal');
  if (modal) {
    modal.classList.add('hidden');
  }
});
//Муравьи
// Удаляем блок ants при gridColumns <= 5
function updateAntsVisibility() {
  const antsBlock = document.getElementById('ants');
  if (!antsBlock) return;

  const gridColumns = parseInt(Elements.gridColumnsInput.value || 3);

  if (gridColumns <= 5) {
    // Очищаем содержимое блока
    antsBlock.innerHTML = '';
  } else {
    // Проверяем, есть ли уже контент
    if (antsBlock.children.length === 0) {
      // Создаём необходимую структуру
      const antContainer = document.createElement('div');
      antContainer.id = 'ant-container';
      antContainer.className = 'pointer-events-none fixed inset-0 z-900';
      
      const borderDiv = document.createElement('div');
      borderDiv.className = 'absolute bottom-0 w-full border-t border-neutral-800/60';
      
      antsBlock.appendChild(antContainer);
      antsBlock.appendChild(borderDiv);
      
      // Перезапускаем анимацию муравьёв
      initAnts();
    }
  }
}


function initAnts() {
      const ANT_COUNT        = 20;
      const MIN_SPEED        = 0.04;
      const MAX_SPEED        = 0.25;
      const FRICTION         = 0.995;
      const SCARE_BOOST      = 0.6;

      /* Параметры стаи */
      const NEIGHBOR_DIST    = 120;
      const CLOSE_DIST       = 40;
      const ALIGN_FACTOR     = 0.05;
      const COHESION_FACTOR  = 0.0009;
      const SEPARATION_FACTOR= 0.03;

      /* Отступ от края, за который нельзя уйти */
      const BORDER_MARGIN    = 20;

      const ants = [];
      const container = document.getElementById('ant-container');
      let W = window.innerWidth;
      let H = window.innerHeight;

      const antSVG = `
        <svg width="20" height="8" viewBox="0 0 20 8" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
          <circle cx="3"  cy="4" r="3"></circle>
          <circle cx="9"  cy="4" r="3"></circle>
          <circle cx="15" cy="4" r="3"></circle>
        </svg>`;

      for (let i = 0; i < ANT_COUNT; i++) {
        const el = document.createElement('div');
        el.innerHTML = antSVG;
        el.className = 'absolute text-neutral-200 transition-transform duration-150 will-change-transform';
        el.style.transformOrigin = 'center';
        container.appendChild(el);

        ants.push({
          el,
          x: Math.random() * (W - 2 * BORDER_MARGIN) + BORDER_MARGIN,
          y: Math.random() * (H - 2 * BORDER_MARGIN) + BORDER_MARGIN,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
        });
      }

      let last = performance.now();
      function tick(now) {
        const dt = now - last;
        last = now;

        // --- стайная логика ---
        for (let i = 0; i < ANT_COUNT; i++) {
          const a = ants[i];

          let avgVX = 0, avgVY = 0, avgX = 0, avgY = 0, count = 0;
          let sepX = 0, sepY = 0, sepCount = 0;

          for (let j = 0; j < ANT_COUNT; j++) {
            if (i === j) continue;
            const b = ants[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist2 = dx*dx + dy*dy;

            if (dist2 < NEIGHBOR_DIST*NEIGHBOR_DIST) {
              avgVX += b.vx;
              avgVY += b.vy;
              avgX  += b.x;
              avgY  += b.y;
              count++;

              if (dist2 < CLOSE_DIST*CLOSE_DIST) {
                sepX -= dx;
                sepY -= dy;
                sepCount++;
              }
            }
          }

          // Alignment
          if (count) {
            a.vx += ((avgVX / count) - a.vx) * ALIGN_FACTOR;
            a.vy += ((avgVY / count) - a.vy) * ALIGN_FACTOR;

            // Cohesion
            a.vx += ((avgX / count) - a.x) * COHESION_FACTOR;
            a.vy += ((avgY / count) - a.y) * COHESION_FACTOR;
          }

          // Separation
          if (sepCount) {
            a.vx += (sepX / sepCount) * SEPARATION_FACTOR;
            a.vy += (sepY / sepCount) * SEPARATION_FACTOR;
          }
        }

        // --- перемещение и отрисовка ---
        ants.forEach(a => {
          a.x += a.vx * dt;
          a.y += a.vy * dt;

          // Фрикционное сглаживание
          a.vx *= FRICTION;
          a.vy *= FRICTION;

          // Ограничение скорости
          let speed = Math.hypot(a.vx, a.vy);
          if (speed < MIN_SPEED) {
            a.vx *= MIN_SPEED / (speed || 1);
            a.vy *= MIN_SPEED / (speed || 1);
          }
          if (speed > MAX_SPEED) {
            a.vx *= MAX_SPEED / speed;
            a.vy *= MAX_SPEED / speed;
          }

          // Жёсткие границы экрана
          if (a.x < BORDER_MARGIN) {
            a.x = BORDER_MARGIN;
            a.vx = Math.abs(a.vx);
          } else if (a.x > W - BORDER_MARGIN) {
            a.x = W - BORDER_MARGIN;
            a.vx = -Math.abs(a.vx);
          }

          if (a.y < BORDER_MARGIN) {
            a.y = BORDER_MARGIN;
            a.vy = Math.abs(a.vy);
          } else if (a.y > H - BORDER_MARGIN) {
            a.y = H - BORDER_MARGIN;
            a.vy = -Math.abs(a.vy);
          }

          const angleDeg = Math.atan2(a.vy, a.vx) * 180 / Math.PI;
          a.el.style.transform = `translate(${a.x}px, ${a.y}px) rotate(${angleDeg}deg)`;
        });

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      // Испуг курсором
      window.addEventListener('mousemove', e => {
        ants.forEach(a => {
          const dx = a.x - e.clientX;
          const dy = a.y - e.clientY;
          const dist2 = dx * dx + dy * dy;
          if (dist2 < 16000) {
            const len = Math.sqrt(dist2) || 1;
            a.vx += (dx / len) * SCARE_BOOST;
            a.vy += (dy / len) * SCARE_BOOST;
          }
        });
      });

      window.addEventListener('resize', () => {
        W = window.innerWidth;
        H = window.innerHeight;
      });
      lucide.createIcons();
    };
</script>

</body>
</html>